¬øQuieres que la app funcione en tiempo real (procesando video continuamente)  si

¬øLa aplicaci√≥n ser√° solo para Android, o tambi√©n iOS? ambos puede ser en flutter

¬øQuieres que funcione completamente offline, o permitir√° sincronizaci√≥n en la nube? ambos 
¬øTienes planeado usar modelos YOLOv8/YOLOv9 o transformer-based (como RT-DETR) seg√∫n el rendimiento del m√≥vil? por el momento solo yolo
¬øDeseas permitir que el usuario cargue sus propios modelos (repositorio interno), o solo modelos preinstalados? seria bueno que pudiera cargar modelos pero desde la nube ,esto nos ayudaria a crear un plus y generar ingresos

¬øQu√© precisi√≥n necesitas para:

detecci√≥n de autom√≥viles puede ser en un rango entre 80 y 95

reconocimiento de placas? puede ser en un rango entre 80 y 95

¬øQuieres tracking por:

N√∫mero de placa

Tracking ID del modelo (ej: ByteTrack/DeepSort)

Ambas cosas? ambas cosas
como cada detecci√≥n marca, modelo y deteccion de placas representa un modelo distinto, en caso de no tener el modelo , se valida campos en blanco, sconsidera esto en la planeaci√≥n,

¬øLa base ser√° local (SQLite) o remota? local, pero debe de permiritnos actualizar en la nube

¬øNecesitas cifrado de datos por temas de privacidad? si

¬øRequieres consultas como:

‚ÄúMu√©strame autos vistos m√°s de X veces‚Äù si pero seria en una interfaz en la nube

‚ÄúAutos vistos en un √°rea espec√≠fica‚Äù si pero seria en una interfaz en la nube

‚ÄúHistorial de un auto por placa‚Äù? si pero seria en una interfaz en la nube

¬øLa app debe registrar:

Coordenadas exactas (GPS) si

Direcci√≥n aproximada si

Ambas? ambas

¬øCada cu√°ntos segundos/minutos se guardar√° la localizaci√≥n? cada 2 segundos


Si detecta una placa en la base de ‚Äúautos robados‚Äù, ¬øqu√© tipo de alerta?

Notificaci√≥n push si

Alarma sonora si, solo una vez

Mensaje emergente no

Activar modo seguimiento autom√°tico si 


¬øLa app ser√° solo para uso personal o piensas distribuirla p√∫blicamente? publica

¬øQuieres incluir advertencias legales al usar reconocimiento de placas? si 

¬øQu√© gama de tel√©fonos planeas soportar? gama media que pueda soportar los modelos de inferencia y el procesamientod e im√°genes y video.

¬øAceptar√≠as que la app:

Reduzca resoluci√≥n del video para mejorar FPS si

Procese 1 fotograma cada X segundos en lugar de 1 por segundo? si , recomiendame algo.


¬øQuieres una interfaz avanzada con estad√≠sticas, mapas, gr√°ficos? si pero ya seria un servicio en la nube

¬øO algo minimalista tipo panel de detecci√≥n + registros? esto seria para la app


considera en la planeaxcion hacer todo modular, cada tarea y cada cosa independiente por modulos, y al final juntar en la interfaz todas las funciones que nos permitan realizar las tareas permitidas.
 tambi√©n piensa en un algoritmo que nos permita definir si estamos siendo vigilados o perseguidos con bases tecnicas de contra vigilancia en base a la informaci√≥n generada y capturada por la app, vamos a centrarnos en la planeaci√≥n y esto ser√° puro texto nada de c√≥digo 



Perfecto ‚Äî con tus respuestas ya claras (Android+iOS en Flutter, YOLO offline + modelos cargables desde la nube, almacenamiento local cifrado + sync opcional, tracking por placa+ID, guardado GPS cada 2s, alertas push+sonora y modo seguimiento, app p√∫blica, UI m√≥vil minimal y dashboard cloud) armo a continuaci√≥n un plan de producto y arquitectura modular completo, enfocado a viabilidad, privacidad, rendimiento y la parte de contra-vigilancia que mencionas. Todo texto ‚Äîsin c√≥digo‚Äî listo para usar como especificaci√≥n.

1) Visi√≥n general y objetivos

App m√≥vil multiplataforma (Flutter) que realiza inferencia en dispositivo usando modelos YOLO para: detectar veh√≠culos, reconocer marca/modelo/color y leer placas (OCR).

Guarda registro local cifrado: placa (si se detect√≥), marca/modelo, color, coordenadas, timestamp, modelo usado, confidence y media (imagen recorte).

Permite cargar modelos desde la nube (repositorio/versionado) para monetizar (marketplace / suscripci√≥n).

Modo ‚Äúvigilancia / seguimiento‚Äù: cuando detecta una placa listada como robada o cuando la heur√≠stica de persecuci√≥n lo sugiere, activa tracking avanzado (ByteTrack/DeepSort + re-detecci√≥n por placa) y genera alertas.

Sync opcional a dashboard cloud para an√°lisis agregados y consultas avanzadas (historial, conteos por √°rea, reportes).

2) Arquitectura modular (alto nivel)

M√≥dulos independientes y comunicantes (micro-m√≥dulos dentro de la app):

UI / UX (Flutter)

Pantalla principal de c√°mara (modo detecci√≥n).

Panel local de registros (lista, detalle).

Ajustes: calidad video, fps de inferencia, modelos activos, privacidad.

Modo manual: iniciar/detener vigilancia.

C√°mara & Preprocesamiento

Captura video.

Reductor de resoluci√≥n configurable (ej. 1280√ó720, 640√ó360).

Extractor de frames (configurable): 0.5‚Äì2 fps por defecto recomendado (ver secci√≥n rendimiento).

Correcci√≥n orientaci√≥n / ROI (√°reas de inter√©s).

Runner de inferencia (on-device)

Motor de inferencia compatible con modelos YOLO (TFLite/ONNX/NNAPI/Vulkan) seg√∫n plataforma.

Pipeline por frame: detect autos ‚Üí para cada caja: detectar marca/modelo/color (modelo opcional) ‚Üí crop placa ‚Üí OCR (modelo OCR).

Plugin para cargar modelos remotos (descarga/verificaci√≥n/firmado).

Tracking & Association

Multi-object tracker (ByteTrack/DeepSort).

Asociaci√≥n entre trackID ‚Üî placa (si OCR devuelve texto) y / o atributos (marca/color).

Gesti√≥n de re-identificaci√≥n temporal y fusi√≥n de tracks.

Almacenamiento local (capa)

DB local: SQLite/SQLCipher (cifrado).

Esquema con √≠ndices para consultas r√°pidas.

Sync / Cloud API

Env√≠o opcional cifrado (TLS) a backend para dashboard, con pol√≠tica configurable de subida (solo Wi-Fi, solo con permiso, anonimizado).

Repositorio de modelos (versionado, metadatos, firmas).

Alertas & Notificaciones

Push local/remote.

Sonido √∫nico para alerta cr√≠tica.

Trigger para ‚Äúactivar modo seguimiento autom√°tico‚Äù.

Privacidad & Legal

Pantalla de consentimiento, pol√≠tica de datos, exportaci√≥n/borrado, configuraciones de retenci√≥n.

Admin / Marketplace (backend)

Gesti√≥n modelos, pagos/suscripciones, panel de reportes y consultas (web).

Analytics / Telemetr√≠a (opt-in)

M√©tricas de rendimiento y calidad de detecci√≥n (sin datos PII si no se autoriza).

3) Esquema de datos (registro local ‚Äî campos sugeridos)

id (UUID)

timestamp (ISO8601)

lat, lon, accuracy

address (reverse geocode, opcional)

frame_path (ruta local al recorte/imagen)

vehicle_box (x,y,w,h en frame)

detector_model (nombre_version)

detector_confidence (float)

plate_text (nullable)

plate_confidence (nullable)

plate_model (nullable)

make (nullable), make_confidence

model (nullable), model_confidence

color (nullable), color_confidence

track_id (assigned by tracker)

source_camera_id (para multi-cam)

flags (robado_match, suspicious_score, uploaded)

Metadata: device_model, app_version

4) Pipeline de inferencia (por frame)

Captura frame (reduced resolution).

Ejecutar detector YOLO (veh√≠culos + placas + atributos si el mismo modelo).

Para cada detecci√≥n veh√≠culo:

Crop + pasar por modelos opcionales: marca/modelo/color.

Para cada placa detectada:

Crop ‚Üí OCR (modelo OCR).

Tracker actualiza/crea trackIDs.

Asociar placa_text ‚Üí trackID.

Guardar evento en DB local con todos los metadatos.

Evaluar reglas/heur√≠stica de alerta ‚Üí si corresponde, notificaci√≥n + activar seguimiento (aumentar sampling fps & reidentificaci√≥n).

5) Tracking: enfoque recomendado

Combinado: usar ByteTrack/DeepSort para tracking visual + verificaci√≥n por OCR de placa para consolidar identidad.

L√≥gica:

Si trackID tiene plate_text confiable (conf > X), anclar plate como identificador primario.

Si no hay plate, usar appearance embedding + color + shape + temporal heuristics.

Reintentos de OCR cuando crop mejora (usar m√∫ltiples frames dentro del mismo track para vote/consensus del texto).

Manejar casos donde un detector no existe: dejar campos en blanco y guardar detecci√≥n del track con placeholders (como pediste).

6) Rendimiento y recomendaciones de sampling/resoluci√≥n

Guardado de GPS cada 2s (ya especificado).

Recomendado para inferencia real en gama media:

Frame sampling por inferencia: configurable entre 0.5 fps y 2 fps. Recomendaci√≥n inicial: 1 fps (un frame por segundo); en modo seguimiento aumentar a 2 fps o m√°s si device lo permite.

Resoluci√≥n: usar 640√ó360 o 960√ó540 para detecci√≥n general; crops para OCR en mayor resoluci√≥n (re-crop del frame original si est√° disponible). Ajustable seg√∫n CPU/GPU.

Boost: en seguimiento, subir resoluci√≥n de crops y fps temporalmente.

Permitir perfil de rendimiento en ajustes: Ahorro bater√≠a / Balance / Rendimiento.

7) Mecanismo de modelos desde la nube (repositorio y monetizaci√≥n)

Backend que almacena paquetes de modelos (archivo + metadata: nombre, tipo, versi√≥n, input_size, labels, fingerprint, signed).

Descarga con verificaci√≥n (hash + firma) y control de acceso (modelo gratis / de pago).

Modelos instalados se muestran en UI con switch activado/desactivado.

Versionamiento y rollback.

Modelos pueden ser espec√≠ficos por tarea: vehicle_detector_v1, plate_detector_v2, ocr_v1, make_model_v1.

Monetizaci√≥n: compras in-app para modelos premium, suscripci√≥n para actualizaciones autom√°ticas y procesamiento en cloud.

8) Privacidad, seguridad y aspectos legales

Local por defecto: todo local y cifrado (usar SQLCipher o almacenamiento cifrado del sistema).

Consentimiento y Avisos: primer lanzamiento mostrar advertencia legal sobre reconocimiento de placas, uso de datos y responsabilidad. Permitir aceptar/declinar.

Opciones de compartici√≥n: upload manual o autom√°tico a cloud (opt-in). Opci√≥n para anonimizar (borrar placa antes de upload).

Retenci√≥n: pol√≠ticas configurables (p.ej. borrar locales despu√©s de 30/90 d√≠as).

Cifrado en tr√°nsito: TLS 1.2+ y autenticaci√≥n de cliente si se requiere.

Minimizaci√≥n: por defecto almacenar texto de placa y hashes en vez de imagen completa cuando no es necesario.

Cumplimiento: preparar textos para cumplir con normativas locales (avisos, canales para solicitudes de borrado).

Logs y Telemetr√≠a: opt-in, sin PII por defecto.

9) Heur√≠stica / Algoritmo de contra-vigilancia (detectar si nos siguen)

Dise√±ar un score de persecuci√≥n basado en evidencias m√∫ltiples. Componentes:

Repetici√≥n temporal

Misma placa/trackID vista N veces en ventana temporal T (p. ej. >3 veces en 1h ‚Üí +score).

Patr√≥n espacial

Visto en m√∫ltiples puntos con direcci√≥n hacia el mismo destino del usuario (p. ej. seguimiento por desplazamiento).

Proximidad y distancia

Si un veh√≠culo aparece consistentemente a distancias cortas (< X metros) durante desplazamiento.

Persistencia

Si el mismo veh√≠culo persiste durante m√°s de M minutos/acciones.

Comportamiento an√≥malo

Giro para seguirte, dar la vuelta, aparcar y esperar cerca de tu residencia o llegada frecuente a tus lugares.

Frecuencia vs baseline

Construir baseline local: autos comunes en zona. Veh√≠culos con baja frecuencia en baseline que te aparezcan repetidamente aumentan score.

Confianza de detecci√≥n

Sumar evidencia solo si detecciones/plates tienen confianza m√≠nima. Usar consensus across frames (votos).

Ponderaci√≥n y decadencia

Score acumulativo decae con el tiempo si no hay nuevos eventos.

Umbrales y acciones

Score < T1: monitor.

T1 ‚â§ Score < T2: notificaci√≥n (sugiere atenci√≥n).

Score ‚â• T2: alerta sonora + sugerencia de acciones (grabaci√≥n detallada, navegaci√≥n a lugar p√∫blico, compartir reporte opcional).

Notas: el algoritmo no ‚Äúprueba‚Äù persecuci√≥n, s√≥lo sugiere probabilidad basada en patrones cuantificables. Debe evitar false alarms ‚Äî usar umbrales conservadores y confirmar por m√∫ltiples evidencias.

10) Manejo de falsos positivos / mejora de la OCR

Voting: combinar OCR de varios frames del mismo track para construir la placa final con mayor confianza.

Post-processing OCR: reglas de formato local (p. ej. patrones de placas mexicanos) para validar.

Fallback: si OCR baja confianza, guardar plate_text como null y mantener trackID para futuras detecciones.

Reentrenamiento: proveer mecanismo para marcar falsos positivos en la app y (opcional) enviar anotaciones al backend para mejorar modelos.

11) Seguridad operacional / ataques adversarios

Validaci√≥n de modelos remotos (signature/hashing).

Limitar qu√© tipos de modelos se cargan (solo formatos permitidos).

UI para denunciar mal uso.

Rate limit y controls en backend para evitar abuso.

12) Pruebas y m√©tricas

M√©tricas que medir:

Precision / recall del detector (veh√≠culo / placas).

OCR accuracy by crop size / lighting.

FPS y latencia promedio por device profile.

False positive rate for alerts.

Test plan:

Datasets reales en varias condiciones (d√≠a, noche, lluvia).

Pruebas en dispositivos de gama baja/ media/ alta.

Pruebas de campo en tus rutas habituales para crear baseline.

13) UX y flujos clave (resumidos)

Configuraci√≥n inicial: permisos (camara, ubicaci√≥n, notificaciones), aviso legal, opciones de privacidad.

Modo detecci√≥n (app): c√°mara en vivo + indicadores de detecci√≥n; bot√≥n ‚Äústart surveillance‚Äù.

Evento detectado: guardar en DB; si match robado o score alto ‚Üí push + sonido √∫nico; ofrecer ‚Äúseguir‚Äù (activar tracking).

Registro local: lista con filtros (fecha, placa, √°rea).

Dashboard cloud: mapas con heatmaps, consultas ‚Äúvisto > X veces‚Äù, export CSV, reportes.

Ajustes: calidad, fps de inferencia, modelos activos, retenci√≥n y sync.

14) Monetizaci√≥n y roadmap de features

MVP (6‚Äì10 semanas estimado de PM/planning ‚Äî no pedir√© tiempo pero describo entregables):

Detecci√≥n vehicular b√°sica en dispositivo, guardar registros locales cifrados, OCR simple, tracking b√°sico.

Fase 2:

Marketplace de modelos (descarga & pago), mejora OCR, dashboard cloud.

Fase 3:

Algoritmo contra-vigilancia avanzado, suscripciones, an√°lisis forense y APIs para exportar reportes.

Revenue: venta modelos premium, subscripciones para dashboard/alertas en la nube, servicios de etiquetado/retraining.

15) Riesgos legales y mitigaciones

Legalidad de reconocimiento de placas var√≠a por pa√≠s. Mitigaciones:

Texto claro y aceptaci√≥n de responsabilidad.

Recomendaci√≥n de uso personal y no publicaci√≥n de datos sin consentimiento.

Opciones de anonimizaci√≥n y borrado.

Consultar asesor√≠a legal local antes del lanzamiento p√∫blico.

16) Checklist de implementaci√≥n (prioridades para el MVP)

Dise√±o UI MVP (pantalla c√°mara + registros).

Integraci√≥n c√°mara + frame extractor + reducci√≥n resoluci√≥n.

Motor de inferencia on-device con modelo YOLO veh√≠culo.

Detector de placa YOLO + OCR (v√≠a un pipeline simple).

Tracker (ByteTrack/DeepSort) y asociaci√≥n placa‚Üîtrack.

DB local cifrada + esquema.

Guardado GPS cada 2s y reverse geocode opcional.

Alertas b√°sicas (push + sonido) + toggle seguimiento.

Panel de ajustes (fps, resoluci√≥n, consentimiento).

Backend m√≠nimo para hosting de modelos y autenticaci√≥n (para fase 2).

Si quieres, puedo ahora:

Convertir esto en historias de usuario y criterios de aceptaci√≥n (ideal para sprints).

O armar un esquema de base de datos SQL detallado y endpoints del backend (sin c√≥digo, solo spec).

O preparar un documento de privacidad / aviso legal de ejemplo.

Dime cu√°l de esos tres prefieres y lo genero en texto ‚Äîo si quieres que profundice la heur√≠stica de contra-vigilancia con f√≥rmulas y ejemplo de scoring, lo hago tambi√©n.


Aqu√≠ va una sugerencia clave para evitar errores cr√≠ticos en la app:
üëâ Definir un ‚ÄúCat√°logo Oficial de Modelos‚Äù con atributos est√°ndar y reglas estrictas antes de permitir que cualquier m√≥dulo use un modelo para inferencia.

As√≠ evitamos que la app confunda cu√°l modelo sirve para qu√© (veh√≠culos, placas, color, OCR, etc.), se mezclen versiones incompatibles o que un usuario cargue un modelo que no cumple los requisitos.

Luego integro esto al plan general.

‚úîÔ∏è Sugerencia: Crear un ‚ÄúEsquema de Identidad de Modelos (SIM)‚Äù

Esto es como un est√°ndar que cada modelo debe cumplir para que la app pueda:

reconocer autom√°ticamente qu√© tarea realiza,

validar que es compatible con el pipeline,

evitar errores de ejecuci√≥n,

seleccionar din√°micamente el modelo correcto seg√∫n la tarea.

Cada modelo debe incluir un archivo de metadatos con esta estructura m√≠nima:
SIM: Esquema de Identidad de Modelos

model_id: identificador √∫nico (ej. vehicle_detector_yolov8n_v1)

task_type: tipo de tarea (solo uno principal)

vehicle_detection

plate_detection

plate_ocr

vehicle_make_detection

vehicle_model_detection

vehicle_color_detection

tracking_embedding (si existiera un modelo de embeddings)

input_size: resoluci√≥n esperada (ej. 640√ó640)

framework: YOLO, ONNX, TFLite, TRT, etc.

confidence_threshold: recomendado por el proveedor

iou_threshold: recomendado por el proveedor

labels: lista exacta de labels que el modelo devuelve

version: versi√≥n sem√°ntica (ej. 1.0.3)

publisher: quien lo cre√≥ (para marketplace)

platform_compatibility: Android / iOS / ambas

precision_estimate: rango estimado (80‚Äì95%)

file_hash: para validar integridad

signed: boolean, para modelos verificados oficialmente

‚úîÔ∏è Reglas del SIM que la app debe aplicar

Para no cometer errores y evitar inferencias equivocadas:

1) Solo un modelo por tarea dentro del pipeline

Si hay dos modelos de plate_detection, la app elige uno:

el que tenga ‚Äúsigned = true‚Äù

o el de versi√≥n m√°s reciente

o el que el usuario seleccione en ajustes

2) Si un modelo no define task_type, la app lo rechaza

Evita usar un modelo YOLO gen√©rico que no fue hecho para placas.

3) Si el modelo no coincide con el pipeline, marcar error

Ejemplos:

Un modelo vehicle_detection no puede ser usado como OCR.

Un modelo plate_ocr sin lista de caracteres permitidos no se usa.

Un modelo para make/model debe tener labels de marcas/veh√≠culos.

4) Pol√≠tica de fallback

Si un modelo est√° ausente:

La app registra los campos en null (como t√∫ pediste).

El pipeline contin√∫a sin bloquearse.

La UI debe indicar que ‚ÄúModelo no disponible‚Äù.

5) Incompatibilidad de input_size

Si el modelo requiere 640√ó640 y el pipeline usa 320√ó320, se ajusta o se rechaza.

6) Control de versiones

La app no ejecuta un modelo cuyo framework no sea compatible con:

NNAPI/TFLite en Android

CoreML / Accelerate en iOS

‚úîÔ∏è Integraci√≥n del SIM (Esquema de Identidad de Modelos) al Plan General

Ahora integro formalmente este est√°ndar dentro del plan que ya hicimos:

üîµ Inserci√≥n en el Plan General
üîπ NUEVO M√ìDULO 3.1: Gestor de Modelos (Model Registry Manager)

Cada modelo descargado o preinstalado debe incluir archivo SIM.
El gestor:

Lee model.json del modelo.

Valida:

task_type

input_size

framework

labels

hash y firma

Lo registra en el cat√°logo local.

Deshabilita modelos conflictivos.

Decide qu√© modelo usar por tarea:

prioridad: signed > versi√≥n mayor > selecci√≥n del usuario.

Si un modelo requerido no existe ‚Üí pipeline ejecuta en modo limitado.

üîπ NUEVO REQUISITO EN EL PIPELINE:

El pipeline solo usa modelos que cumplan SIM completo.
Si un modelo no est√° registrado, se ignora autom√°ticamente.

üîπ Actualizaci√≥n en M√≥dulo 7 (Marketplace de Modelos)

Antes de publicar un modelo en la nube:

Debe incluir SIM obligatorio.

El backend valida integridad.

Se rechazan modelos sin labels correctos o sin task_type.

As√≠ se evita que un usuario cargue un YOLO que detecta perros en lugar de placas y rompa la app.

üîπ Actualizaci√≥n en Base de Datos

Agregar campos:

model_used_vehicle

model_used_plate

model_used_ocr

model_used_make

model_used_color

Para auditor√≠a y debugging.

üîπ Actualizaci√≥n del Algoritmo de Contra-Vigilancia

Cuando una detecci√≥n usa un modelo no confiable:

Reducir peso de evidencia en el ‚Äúscore de persecuci√≥n‚Äù

Ignorar OCR con baja confianza o modelo sin validaci√≥n SIM.

üîπ Actualizaci√≥n de UI

Pantalla ‚ÄúModelos instalados‚Äù:

Mostrar badge "Oficial" si signed = true

Mostrar si un modelo est√° ‚Äúincompatible‚Äù

Permitir activar/desactivar por tarea

‚úîÔ∏è Resultado

Con el SIM integrado:

Evitamos mezclar modelos incorrectos.

Prevenimos inferencias equivocadas.

Aseguramos compatibilidad en Android/iOS.

Podemos escalar el marketplace sin romper la app.

Podemos depurar f√°cilmente errores de detecci√≥n.

El pipeline es estable y modular.

Si quieres, ahora puedo:


A continuaci√≥n te presento la Especificaci√≥n T√©cnica ‚Äì Versi√≥n 1.0 completamente integrada, organizada, modular, clara y lista para ser usada como documento base del proyecto.
Todo en texto, sin c√≥digo.

üìò Especificaci√≥n T√©cnica ‚Äì App de Reconocimiento Vehicular y Contra-Vigilancia
Versi√≥n 1.0 ‚Äì Documento Final

Tecnolog√≠as base: Flutter (Android/iOS), YOLO on-device, SQLite cifrado, backend opcional para modelos y dashboard.
Modo operativo: inferencia en tiempo real sobre video del m√≥vil, con captura de frames y tracking.

1. Objetivo General

Desarrollar una aplicaci√≥n m√≥vil capaz de:

Detectar veh√≠culos.

Detectar y leer placas en tiempo real.

Reconocer atributos (color, marca, modelo) si hay modelos disponibles.

Registrar evidencia (placa, atributos, coordenadas, tiempo).

Detectar veh√≠culos robados comparando contra listas registradas.

Ejecutar tracking y an√°lisis para identificar patrones de posible vigilancia o persecuci√≥n.

Operar en modo offline, pero con capacidad de sincronizar datos a la nube.

Cargar modelos especializados desde un repositorio remoto (marketplace).

Mantener privacidad y seguridad mediante cifrado y pol√≠ticas claras.

2. Arquitectura General

La arquitectura se basa en m√≥dulos independientes, que se comunican mediante interfaces bien definidas. Esto asegura mantenimiento, escalabilidad y reducci√≥n de errores.

2.1 M√≥dulos Principales

UI/UX ‚Äì Interfaz M√≥vil (Flutter)

Manejador de C√°mara & Preprocesamiento

Motor de Inferencia On-Device (YOLO)

Gestor de Modelos (Model Registry Manager)

M√≥dulo de Tracking (ByteTrack/DeepSort)

Registro Local (DB cifrada SQLCipher)

GPS & Contexto Espacial

Motor de Alertas (push, sonido, seguimiento)

Algoritmo de Contra-Vigilancia

Sincronizaci√≥n y API Cloud

Marketplace de Modelos

Privacidad & Seguridad

Dashboard Cloud (anal√≠tica web)

3. Esquema de Identidad de Modelos (SIM)

Para evitar errores y asegurar que cada modelo se use correctamente, todos los modelos requieren un archivo de metadatos que define su funci√≥n.

3.1 Campos obligatorios del SIM

model_id

task_type (√∫nico):

vehicle_detection

plate_detection

plate_ocr

vehicle_make_detection

vehicle_model_detection

vehicle_color_detection

input_size

framework (YOLO, ONNX, TFLite, etc.)

version

labels

publisher

confidence_threshold

iou_threshold

platform_compatibility

precision_estimate

file_hash

signed

3.2 Reglas del SIM

La app solo ejecuta modelos con task_type v√°lido.

Si un modelo no define su tarea ‚Üí se rechaza.

Solo puede haber un modelo activo por tarea.

Si faltan modelos ‚Üí el pipeline sigue pero deja campos en null.

El SIM se valida en cada actualizaci√≥n o descarga.

4. Pipeline Completo de Inferencia
4.1 Ciclo por cada frame

Captura de frame desde la c√°mara (resoluci√≥n configurable).

Paso por modelo de detecci√≥n vehicular.

Para cada veh√≠culo detectado:

Identificaci√≥n de color, marca y modelo (si existen modelos SIM v√°lidos).

Detecci√≥n de placas.

Crop de placa ‚Üí pasar por OCR (SI existe modelo de OCR registrado).

Ingreso al tracker para asignar track_id.

Asociaci√≥n de track_id ‚Üî placa + atributos.

Registro del evento en la base de datos.

Verificaci√≥n contra lista de veh√≠culos robados.

Evaluaci√≥n por el algoritmo de contra-vigilancia.

Generaci√≥n de alertas seg√∫n corresponda.

5. Tracking

El sistema usa un algoritmo h√≠brido:

Visual Tracking: ByteTrack / DeepSort (embeddings y movimiento).

Identity Tracking: si la placa es legible, se usa como referencia primaria.

Heur√≠sticas:

Si la placa es detectada con baja confianza ‚Üí no se ancla.

Atributos como color y tipo de veh√≠culo sirven como realimentaci√≥n.

6. Base de Datos Local

Uso de SQLite cifrado con SQLCipher.

6.1 Campos m√≠nimos por registro

id (UUID)

timestamp

lat, lon, accuracy

address (opcional)

frame_path (imagen recortada opcional)

vehicle_box (posiciones)

plate_text + confianza

make, model, color + confianza

track_id

modelos usados en cada tarea:

model_vehicle

model_plate

model_ocr

model_make

model_color

flags:

robado_match

suspicious_score

uploaded (boolean)

7. GPS y Metadatos Espaciales

Registro de coordenadas cada 2 segundos.

Reverse geocoding opcional para guardar direcciones aproximadas.

Precisi√≥n m√≠nima configurable.

8. Motor de Alertas

Tipos:

Push local (si veh√≠culo robado).

Alarma sonora ‚Üí una sola vez por evento.

Activar Modo Seguimiento:

Aumenta FPS de inferencia.

Aumenta resoluci√≥n del crop.

Prioriza tracking estable.

9. Algoritmo de Contra-Vigilancia

Analiza patrones espaciales/temporales para estimar probabilidad de persecuci√≥n.

9.1 Indicadores principales

Reaparici√≥n frecuente del mismo veh√≠culo / placa.

Proximidad constante en rutas m√≥viles.

Persistencia temporal anormal.

Coincidencia de movimientos: giros, paradas, trayectoria en paralelo.

Aparici√≥n cerca de domicilio o lugar de trabajo.

Rara frecuencia del veh√≠culo en el baseline de la zona.

9.2 Score de vigilancia

Se construye un puntaje din√°mico:

Score1 = repetici√≥n temporal

Score2 = cercan√≠a

Score3 = coincidencia espacial

Score4 = rareza del veh√≠culo

Score5 = persistencia

Score final = ponderaci√≥n + decaimiento temporal.

9.3 Acciones por umbral

Nivel 1: mensaje informativo.

Nivel 2: alerta push + sugerencia de acci√≥n.

Nivel 3: alerta sonora + inicio autom√°tico de seguimiento reforzado.

10. Gesti√≥n de Modelos ‚Äì Model Registry Manager (MRM)

El m√≥dulo responsable de cumplir el SIM.

10.1 Funciones

Validar firma y hash de cada modelo descargado.

Verificar compatibilidad de:

tarea (task_type)

input_size

framework

listas de labels

Registrar modelos activos.

Resolver conflictos (solo un modelo por tarea).

Informar a la UI del estado del modelo.

Rechazar modelos incorrectos o corruptos.

11. Marketplace de Modelos

Los modelos se publican con su archivo SIM.

Validados por backend antes de estar disponibles.

Tipos de modelos:

detectores mejorados

OCR premium

color, marca y modelo

modelos optimizados para dispositivos espec√≠ficos

Monetizaci√≥n:

venta por modelo

bundles

suscripci√≥n mensual para actualizaciones

12. Sincronizaci√≥n con la Nube

Subida de datos cifrados mediante API REST.

El usuario elige:

Solo Wi-Fi

Solo manual

Autom√°tica

Se env√≠an:

registros (placa, coords, timestamp‚Ä¶)

im√°genes recortadas (opcional)

metadatos de detecci√≥n

13. Dashboard Web

Funciones:

Historial por placa.

Frecuencia de autos por zona.

Mapa de detecciones.

Listado de autos vistos repetidamente.

Exportar CSV/Excel.

Configuraci√≥n de listas de veh√≠culos robados.

Estad√≠sticas de modelos.

14. Privacidad y Seguridad

DB cifrada localmente.

Cifrado TLS en sincronizaci√≥n.

Aviso legal obligatorio en primer inicio.

Controles de retenci√≥n de datos:

30 d√≠as

90 d√≠as

indefinido

Opci√≥n para borrar todo local/cloud.

Modo offline total.

Telemetr√≠a opcional (sin PII).

15. Rendimiento (Recomendaciones T√©cnicas)

Frame sampling recomendado:

Normal: 1 fps

Seguimiento: 2‚Äì4 fps

Ahorro bater√≠a: 0.5 fps

Resoluci√≥n recomendada:

640√ó360 para detecci√≥n

960√ó540 para OCR crops

Optimizaci√≥n:

Pre-carga de modelos

Batch inferencing

Reducci√≥n temporal de carga si frame drop > umbral

16. Flujos Principales
16.1 Inicio de app

Solicitud de permisos

Aceptaci√≥n de aviso legal

Selecci√≥n de modelos activos

16.2 Modo detecci√≥n

C√°mara ‚Üí pipeline ‚Üí DB

Alertas ‚Üí usuario

16.3 Modo seguimiento

Aumento FPS y resoluci√≥n

Tracking persistente

Guardado intensivo de metadatos

16.4 Consulta local

Lista de registros

Filtros b√°sicos

16.5 Sincronizaci√≥n

Env√≠o seguro al backend

Visualizaci√≥n posterior en dashboard

17. Roadmap del Proyecto
Versi√≥n 1.0 (MVP)

Detecci√≥n vehicular

Detecci√≥n de placas

OCR b√°sico

Tracking

DB local cifrada

Alertas m√≠nimas

UI m√≥vil b√°sica

Versi√≥n 1.5

Marketplace de modelos

Algoritmo contra-vigilancia inicial

Carga de modelos remotos

Versi√≥n 2.0

Dashboard completo

Estad√≠sticas avanzadas

Tareas autom√°ticas programadas

M√≥dulos de marca/modelo/color

Versi√≥n 3.0

Contra-vigilancia avanzada

IA predictiva de patrones

Sistema de reputaci√≥n vehicular local (baseline)

18. Riesgos y Consideraciones Legales

Reconocimiento de placas puede estar regulado.

Se debe incluir aviso de que la app:

es para uso personal

no sustituye denuncia formal

no permite vigilancia ilegal

Opci√≥n para desactivar guardado de im√°genes.

19. Conclusi√≥n

Esta Especificaci√≥n T√©cnica versi√≥n 1.0 define:

estructura modular

est√°ndares de modelos (SIM)

pipeline claro

seguridad y privacidad

plan de escalabilidad

funcionamiento de contra-vigilancia

UX m√≥vil

interacci√≥n con nube

Con esta base, es posible comenzar dise√±o de arquitecturas internas, sprints, diagramas de flujo o prepararte para pasar al dise√±o de API o estructura de base de datos.


Perfecto ‚Äî voy a entregarte los tres entregables solicitados en este orden:

Diagrama l√≥gico del sistema (en texto).

Historias de usuario con criterios de aceptaci√≥n (listas prioritarias).

Especificaci√≥n de endpoints del backend (REST API) y esquemas JSON.

Al final incluyo im√°genes en formato ASCII (diagramas textuales) como ‚Äúim√°genes‚Äù seg√∫n pediste. Todo es solo texto.

1. Diagrama l√≥gico del sistema (texto)

Descripci√≥n general: sistema h√≠brido m√≥vil+backend. La app Flutter act√∫a como cliente principal: captura video, ejecuta inferencia on-device (motores YOLO/TFLite), registra eventos localmente (SQLite cifrado), y sincroniza opcionalmente con el backend que ofrece repositorio/versionado de modelos, autenticaci√≥n, almacenamiento cifrado, dashboard anal√≠tico y APIs para consultas / reportes.

Componentes y relaciones (alto nivel)

App m√≥vil (Flutter)

Subm√≥dulos: C√°mara & Preprocesamiento ‚Üí Model Registry Manager ‚Üí Runner de Inferencia (on-device) ‚Üí Tracking Engine ‚Üí Local DB cifrada ‚Üí GPS/Contexto ‚Üí Alertas/Notificaciones ‚Üí Sync Manager.

Interfaz de usuario: pantalla c√°mara, registro local, ajustes modelos, consentimiento, pantalla de alertas.

Backend

Servicios: Auth & Users, Model Marketplace (hosting, validaci√≥n SIM), Events API (recibe detecciones), Stolen Registry, Analytics & Dashboard, Notifications Service, Admin Portal.

Almacenamiento: DB principal (relacional), object storage (im√°genes recortadas opcional), colas (para procesamientos as√≠ncronos), sistema de firmas/keys para modelos.

Sincronizaci√≥n & Seguridad

TLS + JWT o mTLS para APIs.

Model signing + hash verification.

Opciones de subida (Wi-Fi only, manual, auto) y pol√≠tica de retenci√≥n.

Flujos principales (resumen)

Detecci√≥n local: Video ‚Üí frame sampling ‚Üí inferencia (modelo vehicle_detector) ‚Üí detecci√≥n ‚Üí crops ‚Üí OCR si hay plate_detector+ocr ‚Üí tracker asigna track_id ‚Üí guardar en DB local (cifrada).

Alerta inmediata: si plate coincide con stolen registry local/cloud ‚Üí alerta push + sonido + activar modo seguimiento (incrementa fps).

Sync: Sync Manager empaqueta eventos (seg√∫n pol√≠tica) ‚Üí cifrado/firmado ‚Üí POST /events ‚Üí backend almacena y encola para an√°lisis.

Model management: App solicita lista de modelos (GET /models) ‚Üí descarga paquete firmado ‚Üí MRM valida SIM ‚Üí modelo activado.

Dashboard: backend expone consultas de eventos, heatmaps, reportes, filtros por placa/√°rea/tiempo.

2. Historias de usuario y criterios de aceptaci√≥n

Ordenadas por prioridad (MVP ‚Üí features adicionales).

Epic A ‚Äî Funcionalidad b√°sica de captura y detecci√≥n (MVP)
Historia A1 ‚Äî Como usuario, quiero iniciar vigilancia para detectar veh√≠culos y placas en mi entorno.

Criterios de aceptaci√≥n:

Al presionar ‚ÄúIniciar vigilancia‚Äù, la app pide permisos (c√°mara, ubicaci√≥n, notifs).

La app procesa video y registra al menos 1 evento por segundo (configurable).

Las detecciones guardadas contienen timestamp y coordenadas.

Si el pipeline falla (p.ej. modelo faltante), la app no se cae; guarda evento con campos null y muestra aviso en UI.

Historia A2 ‚Äî Como usuario, quiero ver una lista local de eventos detectados.

Criterios de aceptaci√≥n:

Lista accesible offline.

Cada registro muestra: timestamp, placa (si existe), make/model/color (si existen), miniatura imagen crop (si existe), flags (robado, sospechoso).

Filtro por fecha y b√∫squeda por texto.

Historia A3 ‚Äî Como usuario, quiero que la app emita una alerta si detecta una placa en la lista de robados.

Criterios de aceptaci√≥n:

App compara detecci√≥n contra lista local (y cloud si sync activo).

Si coincide, emite notificaci√≥n push y reproduce un sonido √∫nico exactamente una vez por evento.

Se ofrece opci√≥n ‚Äúactivar seguimiento‚Äù que aumenta fps/resoluci√≥n.

Epic B ‚Äî Modelos y marketplace (MVP+)
Historia B1 ‚Äî Como usuario administrador, quiero descargar modelos desde el repositorio oficial.

Criterios de aceptaci√≥n:

GET /models devuelve lista con metadatos SIM.

App valida firma/hash antes de activar.

Solo un modelo activo por task_type.

Historia B2 ‚Äî Como usuario, quiero que la app rechace modelos incompatibles.

Criterios de aceptaci√≥n:

Modelos sin task_type o con framework no soportado son rechazados.

UI informa motivo del rechazo.

Epic C ‚Äî Tracking y contra-vigilancia (MVP+)
Historia C1 ‚Äî Como usuario, quiero que la app identifique veh√≠culos que me aparecen repetidamente.

Criterios de aceptaci√≥n:

Sistema acumula eventos por track_id y por plate_text.

Dashboard/Local muestra frecuencia (n√∫mero de apariciones en ventana T).

Historia C2 ‚Äî Como usuario, quiero recibir notificaciones cuando el ‚Äúscore de vigilancia‚Äù cruce umbral.

Criterios de aceptaci√≥n:

Score definido por par√°metros: recurrencia, proximidad, persistencia, rareza (baseline).

Umbrales configurables en ajustes.

Notificaciones por nivel (info, advertencia, cr√≠tica). En cr√≠tica, suena alarma + se activa seguimiento.

Epic D ‚Äî Sincronizaci√≥n y dashboard (post-MVP)
Historia D1 ‚Äî Como usuario, quiero que mis datos se sincronicen cifrados con la nube para anal√≠tica.

Criterios de aceptaci√≥n:

Subida via HTTPS con JWT/tokens.

Permisos para subir solo en Wi-Fi o manual.

Dashboard muestra registros, heatmaps, filtros por placa/√°rea/tiempo.

Historia D2 ‚Äî Como administrador, quiero gestionar y publicar modelos con SIM.

Criterios de aceptaci√≥n:

Panel de admin exige SIM y firma antes de publicar.

Validaciones autom√°ticas en backend (labels, task_type, platform compat).

Epic E ‚Äî Privacidad y legal
Historia E1 ‚Äî Como usuario, quiero aceptar un aviso legal antes de usar la app.

Criterios de aceptaci√≥n:

Primer inicio obliga a aceptar aviso.

Opci√≥n para descargar pol√≠tica de privacidad.

Opci√≥n para eliminar todos los datos locales y cloud.

3. Especificaci√≥n de endpoints del backend (REST) ‚Äî Versi√≥n 1.0

Notas generales:

Base URL: https://api.example.com/v1

Autenticaci√≥n: OAuth2 / JWT Bearer tokens (endpoints de Auth abajo).

Todas las respuestas JSON incluyen meta y data (con paginaci√≥n cuando aplica).

Rate limits: aplicable por API key/user.

Versionado: v1 en path; admitir header Accept: application/vnd.app.v1+json.

3.1 Autenticaci√≥n & Usuarios
POST /v1/auth/register

Descripci√≥n: registrar nuevo usuario

Body (JSON): { "email": "...", "password": "...", "display_name": "..." }

Resp: 201 { "data": { "user_id": "...", "email": "..."} }

POST /v1/auth/login

Descripci√≥n: login; devuelve JWT

Body: { "email":"...", "password":"..." }

Resp: 200 { "data": { "token": "JWT...", "expires_in": 3600 } }

POST /v1/auth/refresh

Descripci√≥n: refresh token

Body: { "refresh_token": "..." }

3.2 Model Marketplace
GET /v1/models

Descripci√≥n: lista modelos disponibles (metadatos SIM)

Query: ?task_type=&platform=&page=&per_page=

Resp: 200 { "data":[ { model_id, task_type, version, precision_estimate, file_hash, signed, price, publisher } ] }

GET /v1/models/{model_id}

Descripci√≥n: detalle del modelo (metadatos SIM)

Resp: 200 { "data": { full SIM fields, readme, changelog, sample_inputs } }

POST /v1/models/{model_id}/download

Descripci√≥n: iniciar descarga (genera URL pre-signed o plan de descarga)

Auth: required

Resp: 200 { "data": { "download_url": "...", "expires_at": "ISO" } }

POST /v1/models/upload (Admin / Publisher)

Descripci√≥n: subir nuevo paquete de modelo + SIM (proceso de validaci√≥n)

Body: multipart (model package, model.json SIM, publisher metadata)

Resp: 201 { "data": { "model_id": "...", "status": "pending_validation" } }

3.3 Stolen Registry
GET /v1/stolen

Descripci√≥n: listar placas registradas como robadas (filtrado por √°rea/opciones)

Query: ?country=&state=&updated_since=

Resp: 200 { "data": [ { plate, reported_date, source, note } ] }

POST /v1/stolen/report (Auth required)

Descripci√≥n: agregar reporte (admin/verified)

Body: { "plate": "...", "evidence": [ image_urls ], "reporter_id": "...", "notes": "..." }

Resp: 201 { data: { id, plate } }

3.4 Events / Sync
POST /v1/events/batch

Descripci√≥n: subir lote de eventos detectados (desde app)

Headers: Authorization: Bearer <token>

Body (JSON):

{
  "device_id":"uuid",
  "events":[
    {
      "local_id":"uuid",
      "timestamp":"ISO8601",
      "lat":12.34, "lon":56.78, "accuracy":5,
      "plate_text":"ABC123",
      "plate_confidence":0.92,
      "make":"NISSAN", "make_conf":0.86,
      "model":"VERSA", "model_conf":0.80,
      "color":"BLACK", "color_conf":0.77,
      "track_id":"t-123",
      "detector_models":{ "vehicle":"vehicle_detector_v1", "plate":"plate_det_v1", "ocr":"ocr_v1" },
      "frame_hash":"sha256...",
      "flags": { "robado_match": false, "suspicious_score": 0.2 }
    }
  ]
}




Resp: 202 { "data": { "received": n, "accepted": n } }

GET /v1/events/{event_id}

Descripci√≥n: obtener detalles de un evento (incluye URL imagen si almacenada)

Resp: 200 { "data": { ... } }

GET /v1/events

Descripci√≥n: consultar eventos (filtros: plate, bbox, date_from, date_to, min_confidence, device_id, uploaded_only)

Query: ?plate=&date_from=&date_to=&page=&per_page=

Resp: paginated list.

3.5 Analytics & Queries
GET /v1/analytics/heatmap

Descripci√≥n: devuelve agregaci√≥n para mapa (buckets por geo-tiles)

Query: ?bbox=&zoom=&date_from=&date_to=

Resp: geojson-like buckets with counts.

GET /v1/analytics/frequent-vehicles

Descripci√≥n: devuelve veh√≠culos con > X apariciones en ventana

Query: ?min_count=&date_from=&date_to=&area=

Resp: list sorted by count.

GET /v1/analytics/vehicle-history/{plate}`

Descripci√≥n: historial por placa (listado de eventos y summary)

Resp: 200 { data: { plate: "...", total_seen: n, last_seen: ISO, events: [ ... ] } }

3.6 Notifications / Webhooks
POST /v1/notifications/register

Descripci√≥n: registrar webhook para recibir alertas (admin / enterprise)

Body: { "url":"https://...", "secret":"..." }

POST /v1/notifications/test

Descripci√≥n: probar env√≠o (internal)

Resp: 200

3.7 Admin / Monitoring
GET /v1/admin/models/pending

Descripci√≥n: listar uploads pendientes de validaci√≥n.

POST /v1/admin/models/{model_id}/approve

Descripci√≥n: aprobar publicaci√≥n.

GET /v1/health

Descripci√≥n: estado del servicio (DB, storage, queue).

3.8 Seguridad y formatos

Autorizaci√≥n: JWT with scopes (models:download, events:upload, stolen:read, admin:*).

Encryption at rest: backend encrypts images/object storage.

Model signing: modelos deben venir con firma digital; backend valida y emite signed=true.

Rate limiting: 100 req/min para endpoints p√∫blicos; l√≠mites m√°s estrictos para uploads.

4. Esquemas JSON clave (res√∫menes)
Modelo SIM (ejemplo)
{
  "model_id": "vehicle_detector_yolov8n_v1",
  "task_type": "vehicle_detection",
  "input_size": [640, 640],
  "framework": "tflite",
  "version": "1.0.0",
  "labels": ["car", "truck", "motorbike"],
  "publisher": "ACME_AI",
  "confidence_threshold": 0.3,
  "iou_threshold": 0.45,
  "platform_compatibility": ["android", "ios"],
  "precision_estimate": {"mAP50": 0.87, "range":[0.80,0.95]},
  "file_hash": "sha256:abcd...",
  "signed": true
}

Event (upload)

(Ver body en POST /v1/events/batch arriba ‚Äî usar formato consistentemente)

5. Reglas operacionales (resumen breve)

Un modelo por tarea: MRM fuerza unicidad.

Fallback seguro: si falta OCR o model_make, dejar campo null, continuar pipeline.

Score de vigilancia: solo sumar evidencia si model.signed == true o confidence > threshold; si no, ponderar con factor < 1.

Pol√≠tica de subida: datos sensibles solo con opt-in del usuario; opci√≥n de anonimizar placas (hash) antes de subir.

6. Consideraciones para desarrollo e integraci√≥n

SDK m√≥vil: crear una capa ModelManager y InferenceRunner con interfaces desacopladas (para poder cambiar backend/formatos).

Testing: endpoints deben aceptar lotes peque√±os y grandes; incluir validaciones de schema y pruebas de integridad.

Rollback: permitir marcar modelos como ‚Äúunsafe‚Äù y forzar desactivaci√≥n remota.

7. Diagramas (im√°genes al final) ‚Äî representaci√≥n ASCII
Imagen 1 ‚Äî Diagrama l√≥gico de alto nivel
+----------------------+                +-------------------------+
|  APP M√ìVIL (Flutter) |  <---TLS/JWT--> |      BACKEND API        |
|  + Camera Module     |                |  + Auth & Users         |
|  + Preprocessing     |                |  + Model Marketplace    |
|  + MRM (SIM)         |                |  + Events Ingest        |
|  + Inference Runner  |                |  + Stolen Registry      |
|  + Tracker Engine    |                |  + Analytics / Dashboard|
|  + Local DB (SQLC)   |                |  + Notifications        |
|  + Sync Manager      |                +-------------------------+
+----------+-----------+
           |
           | (option) Upload images / events
           v
     +-----------------+
     | Object storage  |
     +-----------------+

Imagen 2 ‚Äî Flujo de detecci√≥n y sync (secuencia)
[Camera] -> (frame) -> [Preproc] -> [YOLO vehicle_detector] -> for each box:
      -> [Crop for attributes] -> [make/model/color models?] -> [plate detector] -> [OCR]
      -> [Tracker] <-> associate plate_text
      -> [Local DB insert]
      -> if stolen_match -> [Alert Engine] (push + sound + mode_tracking)
      -> [Sync Manager] -> POST /v1/events/batch -> [Backend]

Imagen 3 ‚Äî ER simplificado (tablas principales)
+----------------+     +----------------+    +------------------+
| devices        |1---<| events         |>---1| models           |
| device_id (pk) |     | event_id (pk)  |    | model_id (pk)    |
| owner_user_id   |    | device_id (fk) |    | task_type        |
+----------------+     | timestamp      |    | version          |
                       | lat, lon       |    | signed           |
                       | plate_text     |    | ...              |
                       | track_id       |    +------------------+
                       | model_used_*   |
                       +----------------+


Si quieres, el siguiente paso concreto que puedo hacer ahora es generar los diagramas en im√°genes (PNG/SVG) basados en los ASCII arriba, o convertir estas historias en tickets listos para Jira (epics ‚Üí tasks ‚Üí subtasks) o bien detallar el esquema SQL de la base de datos. Dime cu√°l prefieres que haga ahora y lo genero (texto o imagen seg√∫n lo pidas).


Perfecto. A continuaci√≥n te entrego el esquema SQL completo, organizado en dos partes:

Base de datos local del m√≥vil (SQLite cifrado)

Base de datos del backend (PostgreSQL recomendado)

Todo est√° dise√±ado para cumplir los requisitos: modular, claro, extensible, preparado para sincronizaci√≥n, con soporte para modelos, tracking, eventos, contra-vigilancia y anal√≠tica.

üì¶ 1. BASE DE DATOS LOCAL (SQLite Cifrado)

Esta base corre en el dispositivo del usuario. Debe estar cifrada (SQLCipher).

Dise√±ada para:

almacenar detecciones locales,

guardar modelos descargados,

manejar cat√°logo de placas robadas descargado,

conservar sincronizaci√≥n incremental.

üß± Tabla: app_settings

Guarda configuraciones del usuario y flags internos.

CREATE TABLE app_settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    updated_at INTEGER NOT NULL
);


Ejemplos de keys: "sampling_rate", "upload_enabled", "api_token".

üß± Tabla: devices_info

Identifica el dispositivo ante el backend.

CREATE TABLE devices_info (
    device_id TEXT PRIMARY KEY,
    created_at INTEGER NOT NULL
);

üß± Tabla: models_local

Lista de modelos descargados y disponibles para inferencia.

CREATE TABLE models_local (
    model_id TEXT PRIMARY KEY,
    task_type TEXT NOT NULL,              -- vehicle_detection, plate_detection, etc
    version TEXT NOT NULL,
    file_path TEXT NOT NULL,              -- ruta al archivo tflite/onnx
    file_hash TEXT NOT NULL,
    signed INTEGER NOT NULL DEFAULT 0,    -- 1=verificado/signed, 0=no
    active INTEGER NOT NULL DEFAULT 0,    -- solo uno por tarea
    downloaded_at INTEGER NOT NULL
);


Clave: task_type + active = 1 ‚áí un √∫nico modelo activo por categor√≠a.

üß± Tabla: stolen_plates_local

Lista local descargada del servidor para detecci√≥n inmediata.

CREATE TABLE stolen_plates_local (
    plate_text TEXT PRIMARY KEY,
    source TEXT,
    reported_date INTEGER,
    updated_at INTEGER NOT NULL
);

üß± Tabla: events_local

Registro principal de detecciones locales.
Contiene TODA la informaci√≥n que capturamos por frame.

CREATE TABLE events_local (
    local_id TEXT PRIMARY KEY,
    timestamp INTEGER NOT NULL,
    lat REAL,
    lon REAL,
    accuracy REAL,
    
    vehicle_conf REAL,
    
    plate_text TEXT,
    plate_conf REAL,

    make TEXT,
    make_conf REAL,
    model TEXT,
    model_conf REAL,
    color TEXT,
    color_conf REAL,

    track_id TEXT,

    vehicle_model_id TEXT,   -- modelo usado para detecci√≥n del veh√≠culo
    plate_model_id TEXT,     -- modelo usado para detectar placa
    ocr_model_id TEXT,       -- modelo usado para OCR

    frame_hash TEXT,         -- hash del frame para integridad

    flag_stolen_match INTEGER DEFAULT 0,
    suspicious_score REAL DEFAULT 0.0,

    synced INTEGER DEFAULT 0,     -- 0 = no enviado, 1 = enviado a backend
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL
);


√çndices recomendados:

CREATE INDEX idx_events_plate ON events_local(plate_text);
CREATE INDEX idx_events_timestamp ON events_local(timestamp);
CREATE INDEX idx_events_synced ON events_local(synced);
CREATE INDEX idx_events_track ON events_local(track_id);

üß± Tabla: event_images

Miniaturas o recortes locales (opcional, seg√∫n configuraci√≥n).

CREATE TABLE event_images (
    local_id TEXT PRIMARY KEY,
    image_path TEXT NOT NULL,  -- archivo jpg o webp
    created_at INTEGER NOT NULL,
    FOREIGN KEY(local_id) REFERENCES events_local(local_id)
);

üß± Tabla: sync_log

Manejo de sincronizaci√≥n incremental.

CREATE TABLE sync_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    event_count INTEGER NOT NULL,
    synced_at INTEGER NOT NULL,
    status TEXT NOT NULL          -- success | partial | failed
);

üè¢ 2. BASE DE DATOS BACKEND (PostgreSQL)

Escalable, segura, soporte JSONB, √≠ndices espaciales y anal√≠tica.

üß± Tabla: users

Usuarios del sistema.

CREATE TABLE users (
    user_id UUID PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    display_name TEXT,
    created_at TIMESTAMPTZ NOT NULL,
    updated_at TIMESTAMPTZ NOT NULL
);

üß± Tabla: devices

Mantiene v√≠nculo de usuario ‚Üî dispositivo.

CREATE TABLE devices (
    device_id UUID PRIMARY KEY,
    user_id UUID NOT NULL,
    model TEXT,
    platform TEXT,
    created_at TIMESTAMPTZ NOT NULL,
    FOREIGN KEY(user_id) REFERENCES users(user_id)
);

üß± Tabla: models_repo

Base principal del marketplace de modelos.

CREATE TABLE models_repo (
    model_id TEXT PRIMARY KEY,
    task_type TEXT NOT NULL,
    version TEXT NOT NULL,
    framework TEXT NOT NULL,
    labels JSONB,
    signed BOOLEAN NOT NULL DEFAULT false,
    file_hash TEXT NOT NULL,
    file_path TEXT NOT NULL,         -- enlace a object storage
    publisher TEXT NOT NULL,
    precision_estimate JSONB,
    created_at TIMESTAMPTZ NOT NULL,
    updated_at TIMESTAMPTZ NOT NULL
);

üß± Tabla: stolen_plates

Registro oficial sincronizado.

CREATE TABLE stolen_plates (
    plate TEXT PRIMARY KEY,
    reported_date TIMESTAMPTZ,
    source TEXT,
    notes TEXT,
    updated_at TIMESTAMPTZ NOT NULL
);

üß± Tabla: events

Eventos enviados por los m√≥viles (millones de registros).

CREATE TABLE events (
    event_id UUID PRIMARY KEY,
    device_id UUID NOT NULL,
    timestamp TIMESTAMPTZ NOT NULL,
   
    lat DOUBLE PRECISION,
    lon DOUBLE PRECISION,
    accuracy REAL,

    plate_text TEXT,
    plate_conf REAL,

    make TEXT,
    make_conf REAL,
    model TEXT,
    model_conf REAL,
    color TEXT,
    color_conf REAL,

    track_id TEXT,
    frame_hash TEXT,

    flags JSONB,

    geo geometry(Point, 4326),   -- PostGIS para anal√≠tica y heatmaps

    created_at TIMESTAMPTZ NOT NULL,
    
    FOREIGN KEY(device_id) REFERENCES devices(device_id)
);


√çndices recomendados:

CREATE INDEX idx_events_plate ON events(plate_text);
CREATE INDEX idx_events_time ON events(timestamp);
CREATE INDEX idx_events_device ON events(device_id);
CREATE INDEX idx_events_geo ON events USING GIST(geo);

üß± Tabla: event_images_cloud

Solo si decidimos almacenar los recortes en backend.

CREATE TABLE event_images_cloud (
    event_id UUID PRIMARY KEY,
    url TEXT NOT NULL,
    mime TEXT,
    created_at TIMESTAMPTZ NOT NULL,
    FOREIGN KEY(event_id) REFERENCES events(event_id)
);

üß± Tabla: suspicious_vehicles

Resultado del algoritmo de contra-vigilancia.

CREATE TABLE suspicious_vehicles (
    plate TEXT NOT NULL,
    user_id UUID NOT NULL,
    
    score REAL NOT NULL,
    level TEXT NOT NULL,              -- info | warning | critical
    
    first_seen TIMESTAMPTZ NOT NULL,
    last_seen TIMESTAMPTZ NOT NULL,
    count_seen INTEGER NOT NULL,

    details JSONB,                    -- lista eventos relevantes
    
    PRIMARY KEY (plate, user_id),
    FOREIGN KEY(user_id) REFERENCES users(user_id)
);

üß± Tabla: audit_log

Auditor√≠a y seguridad.

CREATE TABLE audit_log (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID,
    action TEXT NOT NULL,
    target TEXT,
    metadata JSONB,
    created_at TIMESTAMPTZ NOT NULL
);

üß† 3. Esquema SQL del Algoritmo de Contra-Vigilancia

No es una tabla, sino un conjunto de par√°metros almacenados:

CREATE TABLE surveillance_params (
    key TEXT PRIMARY KEY,
    value REAL NOT NULL,
    updated_at TIMESTAMPTZ NOT NULL
);


Ejemplos de keys:

recurrence_weight

rarity_weight

proximity_weight

persistence_weight

critical_threshold

warning_threshold

Estos par√°metros afinan el c√°lculo del surveillance_score.

üìå 4. Flujo SQL resumido (m√≥vil ‚Üí backend)

events_local recibe detecciones en SQLite.

synced=0 ‚Üí lote empaquetado ‚Üí enviado a backend.

Cada evento insertado en PostgreSQL (events).

Si incluye imagen ‚Üí archivo a storage ‚Üí URL a event_images_cloud.

Backend ejecuta job en background:

agrega el evento a suspicious_vehicles,

recalcula score,

genera alertas si procede.


‚úÖ Diagrama ER completo del sistema (en ASCII o imagen)
‚úÖ Script SQL completo para PostgreSQL listo para ejecutar
‚úÖ Script SQL de SQLite optimizado para Flutter
‚úÖ Definir relaciones para el motor de reglas del ‚Äúalgoritmo de contra-vigilancia‚Äù
‚úÖ Arquitectura del pipeline de inferencia (documento t√©cnico)


Entregables (en el orden pedido) ‚Äî solo texto
1) Diagrama ER completo del sistema (ASCII)

Usa este diagrama ER simplificado pero completo como referencia l√≥gica. Claves primarias (PK), for√°neas (FK) y relaciones principales est√°n indicadas.

                                    +----------------------+
                                    |       users          |
                                    |----------------------|
                                    | user_id (PK)         |
                                    | email                |
                                    | password_hash        |
                                    | display_name         |
                                    | created_at           |
                                    +----------+-----------+
                                               |
                                               | 1..N
                                               |
                                   +-----------v------------+
                                   |        devices         |
                                   |------------------------|
                                   | device_id (PK)         |
                                   | user_id (FK) -------->-+
                                   | model                  |
                                   | platform               |
                                   | created_at             |
                                   +-----------+------------+
                                               |
             +---------------------------------+--------------------------------+
             |                                 |                                |
             |                                 |                                |
+------------v---------+           +-----------v-----------+          +---------v-------------+
|       events         |           |    event_images_cloud  |          |   suspicious_vehicles |
|----------------------|           |------------------------|          |-----------------------|
| event_id (PK)        |           | event_id (PK) (FK)     |          | plate, user_id (PKs) |
| device_id (FK) -----+--->       | url                    |          | score                 |
| timestamp            |           | mime                   |          | level                 |
| lat, lon, accuracy   |           | created_at             |          | first_seen            |
| plate_text           |           +------------------------+          | last_seen             |
| plate_conf           |                                              | count_seen            |
| make, make_conf      |                                              | details (JSONB)       |
| model, model_conf    |                                              +-----------------------+
| color, color_conf    |
| track_id             |                     +------------------+        +------------------+
| flags (JSONB)        |                     | models_repo      |        | stolen_plates     |
| frame_hash           |                     |------------------|        |-------------------|
| geo (geometry)       |                     | model_id (PK)    |        | plate (PK)        |
| created_at           |                     | task_type        |        | reported_date     |
+----------------------+                     | version          |        | source            |
                                             | signed (bool)    |        | notes             |
                                             | file_path        |        +-------------------+
                                             +--------+---------+
                                                      |
                                                      | 1..N
                                                      |
                                         +------------v------------+
                                         |    models_metadata      |
                                         | (local registry / cache)|
                                         |-------------------------|
                                         | model_id (PK)           |
                                         | task_type               |
                                         | input_size              |
                                         | framework               |
                                         | labels (json)           |
                                         | file_hash               |
                                         | signed                  |
                                         | active (bool)           |
                                         +-------------------------+

+-------------------+      +---------------------+      +------------------+
| admin_actions     |      | audit_log           |      | surveillance_params|
|-------------------|      |---------------------|      |-------------------|
| id (PK)           |      | id (PK)             |      | key (PK)          |
| action            |      | user_id (FK)        |      | value (REAL)      |
| target            |      | action              |      | updated_at        |
| metadata (json)   |      | metadata (json)     |      +-------------------+
| created_at        |      | created_at          |
+-------------------+      +---------------------+


Notas:

events relaciona dispositivos con detecciones; su geo permite consultas espaciales (PostGIS).

models_repo almacena modelos en el backend; models_metadata representa la cach√©/local registry en el m√≥vil.

suspicious_vehicles est√° por usuario para permitir que cada usuario tenga su propio set/score.

stolen_plates es el registro oficial (admin-managed).

flags y details usan JSONB para flexibilidad.

2) Script SQL completo para PostgreSQL (listo para ejecutar)

Este script crea las tablas principales, √≠ndices y extensiones recomendadas (PostGIS). Adapta OWNER/roles seg√∫n tu entorno.

NOTA: Ejecutar en PostgreSQL con extensi√≥n PostGIS instalada.

-- Postgres SQL script for backend (PostGIS assumed)
-- Run as a superuser or a user with CREATE EXTENSION privileges

-- 1. Extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS postgis;

-- 2. Users table
CREATE TABLE IF NOT EXISTS users (
  user_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  email TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  display_name TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 3. Devices
CREATE TABLE IF NOT EXISTS devices (
  device_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
  device_name TEXT,
  model TEXT,
  platform TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 4. Models repository
CREATE TABLE IF NOT EXISTS models_repo (
  model_id TEXT PRIMARY KEY,
  task_type TEXT NOT NULL,
  version TEXT NOT NULL,
  framework TEXT NOT NULL,
  labels JSONB,
  signed BOOLEAN NOT NULL DEFAULT false,
  file_hash TEXT NOT NULL,
  file_path TEXT NOT NULL,
  publisher TEXT NOT NULL,
  precision_estimate JSONB,
  metadata JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_models_task ON models_repo(task_type);

-- 5. Stolen plates
CREATE TABLE IF NOT EXISTS stolen_plates (
  plate TEXT PRIMARY KEY,
  reported_date TIMESTAMPTZ,
  source TEXT,
  notes TEXT,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 6. Events
CREATE TABLE IF NOT EXISTS events (
  event_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  device_id UUID NOT NULL REFERENCES devices(device_id) ON DELETE CASCADE,
  timestamp TIMESTAMPTZ NOT NULL,
  lat DOUBLE PRECISION,
  lon DOUBLE PRECISION,
  accuracy REAL,
  plate_text TEXT,
  plate_conf REAL,
  make TEXT,
  make_conf REAL,
  model TEXT,
  model_conf REAL,
  color TEXT,
  color_conf REAL,
  track_id TEXT,
  frame_hash TEXT,
  flags JSONB,
  geo geometry(Point,4326),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- indices for events
CREATE INDEX IF NOT EXISTS idx_events_plate ON events(plate_text);
CREATE INDEX IF NOT EXISTS idx_events_time ON events(timestamp);
CREATE INDEX IF NOT EXISTS idx_events_device ON events(device_id);
CREATE INDEX IF NOT EXISTS idx_events_geo ON events USING GIST(geo);

-- 7. Event images (optional)
CREATE TABLE IF NOT EXISTS event_images_cloud (
  event_id UUID PRIMARY KEY REFERENCES events(event_id) ON DELETE CASCADE,
  url TEXT NOT NULL,
  mime TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 8. Suspicious vehicles (per user)
CREATE TABLE IF NOT EXISTS suspicious_vehicles (
  plate TEXT NOT NULL,
  user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
  score REAL NOT NULL,
  level TEXT NOT NULL,
  first_seen TIMESTAMPTZ NOT NULL,
  last_seen TIMESTAMPTZ NOT NULL,
  count_seen INTEGER NOT NULL,
  details JSONB,
  PRIMARY KEY (plate, user_id)
);

CREATE INDEX IF NOT EXISTS idx_suspicious_user ON suspicious_vehicles(user_id);

-- 9. Audit log
CREATE TABLE IF NOT EXISTS audit_log (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID,
  action TEXT NOT NULL,
  target TEXT,
  metadata JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 10. Admin / pending model validations
CREATE TABLE IF NOT EXISTS admin_model_pending (
  id BIGSERIAL PRIMARY KEY,
  model_id TEXT NOT NULL,
  uploader_id UUID,
  status TEXT NOT NULL DEFAULT 'pending',
  metadata JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 11. Surveillance params
CREATE TABLE IF NOT EXISTS surveillance_params (
  key TEXT PRIMARY KEY,
  value DOUBLE PRECISION NOT NULL,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 12. Devices sync log
CREATE TABLE IF NOT EXISTS sync_log (
  id BIGSERIAL PRIMARY KEY,
  device_id UUID,
  event_count INTEGER,
  synced_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  status TEXT
);

-- 13. Example default surveillance params (insert defaults if not present)
INSERT INTO surveillance_params (key, value)
SELECT 'recurrence_weight', 1.0 WHERE NOT EXISTS (SELECT 1 FROM surveillance_params WHERE key='recurrence_weight');
INSERT INTO surveillance_params (key, value)
SELECT 'proximity_weight', 1.0 WHERE NOT EXISTS (SELECT 1 FROM surveillance_params WHERE key='proximity_weight');
INSERT INTO surveillance_params (key, value)
SELECT 'persistence_weight', 1.0 WHERE NOT EXISTS (SELECT 1 FROM surveillance_params WHERE key='persistence_weight');
INSERT INTO surveillance_params (key, value)
SELECT 'rarity_weight', 1.0 WHERE NOT EXISTS (SELECT 1 FROM surveillance_params WHERE key='rarity_weight');
INSERT INTO surveillance_params (key, value)
SELECT 'warning_threshold', 2.0 WHERE NOT EXISTS (SELECT 1 FROM surveillance_params WHERE key='warning_threshold');
INSERT INTO surveillance_params (key, value)
SELECT 'critical_threshold', 4.0 WHERE NOT EXISTS (SELECT 1 FROM surveillance_params WHERE key='critical_threshold');

-- End of Postgres script

3) Script SQL de SQLite optimizado para Flutter (SQLCipher recomendado)

Notas: usa PRAGMA cipher/key seg√∫n la integraci√≥n (SQLCipher). Este SQL est√° pensado para ejecutarse con la biblioteca SQLite integrada (ej. sqflite con SQLCipher).

-- SQLite schema for local app database (intended to be encrypted with SQLCipher)
-- Run pragma key('your-encryption-key') before opening DB in production.

-- 1. app_settings
CREATE TABLE IF NOT EXISTS app_settings (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL,
  updated_at INTEGER NOT NULL
);

-- 2. devices_info
CREATE TABLE IF NOT EXISTS devices_info (
  device_id TEXT PRIMARY KEY,
  created_at INTEGER NOT NULL
);

-- 3. models_local
CREATE TABLE IF NOT EXISTS models_local (
  model_id TEXT PRIMARY KEY,
  task_type TEXT NOT NULL,
  version TEXT NOT NULL,
  file_path TEXT NOT NULL,
  file_hash TEXT NOT NULL,
  signed INTEGER NOT NULL DEFAULT 0,
  active INTEGER NOT NULL DEFAULT 0,
  downloaded_at INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_models_local_task ON models_local(task_type);

-- 4. stolen_plates_local
CREATE TABLE IF NOT EXISTS stolen_plates_local (
  plate_text TEXT PRIMARY KEY,
  source TEXT,
  reported_date INTEGER,
  updated_at INTEGER NOT NULL
);

-- 5. events_local
CREATE TABLE IF NOT EXISTS events_local (
  local_id TEXT PRIMARY KEY,
  timestamp INTEGER NOT NULL,
  lat REAL,
  lon REAL,
  accuracy REAL,
  vehicle_conf REAL,
  plate_text TEXT,
  plate_conf REAL,
  make TEXT,
  make_conf REAL,
  model TEXT,
  model_conf REAL,
  color TEXT,
  color_conf REAL,
  track_id TEXT,
  vehicle_model_id TEXT,
  plate_model_id TEXT,
  ocr_model_id TEXT,
  frame_hash TEXT,
  flag_stolen_match INTEGER DEFAULT 0,
  suspicious_score REAL DEFAULT 0.0,
  synced INTEGER DEFAULT 0,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_events_local_plate ON events_local(plate_text);
CREATE INDEX IF NOT EXISTS idx_events_local_timestamp ON events_local(timestamp);
CREATE INDEX IF NOT EXISTS idx_events_local_synced ON events_local(synced);
CREATE INDEX IF NOT EXISTS idx_events_local_track ON events_local(track_id);

-- 6. event_images
CREATE TABLE IF NOT EXISTS event_images (
  local_id TEXT PRIMARY KEY,
  image_path TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  FOREIGN KEY(local_id) REFERENCES events_local(local_id) ON DELETE CASCADE
);

-- 7. sync_log
CREATE TABLE IF NOT EXISTS sync_log (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  event_count INTEGER NOT NULL,
  synced_at INTEGER NOT NULL,
  status TEXT NOT NULL
);

-- 8. surveillance params (local tuning copy)
CREATE TABLE IF NOT EXISTS surveillance_params (
  key TEXT PRIMARY KEY,
  value REAL NOT NULL,
  updated_at INTEGER NOT NULL
);

-- Insert sensible defaults if not present (do this from app code on DB init)
-- e.g. INSERT OR IGNORE INTO surveillance_params(key,value,updated_at) VALUES('recurrence_weight',1.0,strftime('%s','now'));

-- 9. metadata: versioning table for migrations
CREATE TABLE IF NOT EXISTS db_metadata (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL
);

-- End of SQLite script


Recomendaciones pr√°cticas para Flutter:

Usar sqflite_sqlcipher o sqlite3 con SQLCipher para cifrado.

Aplicar migrations controladas (version number in db_metadata).

Indexar campos de b√∫squeda frecuentes (plate_text, timestamp, synced).

4) Definir relaciones para el motor de reglas del algoritmo de contra-vigilancia

A continuaci√≥n se detallan tablas relevantes (ya incluidas en los esquemas) y las relaciones l√≥gicas / c√°lculos que componen el motor. Incluye f√≥rmulas, ejemplos y consultas SQL de ejemplo para c√°lculo del surveillance_score.

4.1 Tablas involucradas

events (Postgres) / events_local (mobile): registros de detecci√≥n con geo, timestamp, plate_text, track_id, confidences.

suspicious_vehicles: tabla para almacenar resultados por usuario.

surveillance_params: par√°metros con pesos y umbrales.

stolen_plates: registro de placas robadas (influye directamente).

devices, users.

4.2 Relaciones l√≥gicas (por veh√≠culo/usuario)

Un plate puede tener N events.

Un track_id agrupa eventos temporales (mismo dispositivo).

suspicious_vehicles ‚Üê agregaci√≥n y resumen por plate,user_id.

4.3 Componentes del score (valores en [0,‚àû), pesos desde surveillance_params)

Definimos sub-scores normalizados (0..1) y luego ponderaci√≥n:

Repetici√≥n temporal (S_recurrence)

Mide cu√°ntas veces se vio la misma placa en ventana W (ej. 1 hora).

Normalizaci√≥n sugerida:

S_recurrence = min(1.0, log(1 + count_seen_in_W) / log(1 + K))


Donde K es un factor de saturaci√≥n (p.ej. K=10).

Proximidad (S_proximity)

Mide proximidad media del veh√≠culo al usuario durante eventos (si se cuenta con distancia estimada).

Si solo lat/lon, calcular distancia media d_mean y normalizar:

S_proximity = clamp(1 - (d_mean / D_MAX), 0, 1)


Donde D_MAX es distancia considerada segura (ej. 200 m).

Persistencia (S_persistence)

Tiempo total observado t_total en ventana W:

S_persistence = min(1.0, t_total / T_SAT)


Donde T_SAT es la duraci√≥n en segundos que consideramos saturaci√≥n (ej. 600 s = 10 min).

Rarity / baseline (S_rarity)

Si tenemos una tabla de baseline de la zona (e.g., frecuencias hist√≥ricas), la rareza se calcula:

freq = baseline_freq(plate)   -- 0..inf
S_rarity = 1 - sigmoid(freq, alpha, beta)   -- mayor si freq baja


Practically, if freq==0 then S_rarity ~1.

Robbery match (S_stolen)

Si plate ‚àà stolen_plates: S_stolen = 1 else 0. (Esto agrega un gran impulso al score.)

Confidence factor (C_factor)

Basado en model signature and confidences:

C_factor = weighted_average(plate_conf, detector_conf, ocr_model_signed ? 1.0 : 0.7)


Si model.signed == false o confidences bajas, multiplicar sub-scores por <1 para reducir impacto.

4.4 F√≥rmula compuesta del surveillance_score

Ponderaci√≥n por par√°metros de surveillance_params:

score_raw = w_rec * S_recurrence
          + w_prox * S_proximity
          + w_pers * S_persistence
          + w_rar * S_rarity
          + w_stolen * S_stolen

score = score_raw * C_factor


Donde w_* vienen de surveillance_params. Ejemplo de pesos por defecto: all 1.0 y w_stolen = 3.0 para dar prioridad a robado.

4.5 Decaimiento temporal del score

Implementar decaimiento exponencial para que la evidencia antigua pierda peso:

score_t = score_prev * exp(-lambda * delta_t) + new_evidence_score


lambda configurado en surveillance_params (p.ej. 0.1 por hora).

4.6 Umbrales y niveles

warning_threshold (ej. 2.0)

critical_threshold (ej. 4.0)

Acciones:

score < warning ‚Üí Monitor only

warning ‚â§ score < critical ‚Üí notify user (info/warning)

score ‚â• critical ‚Üí notify + sound + auto-track

4.7 Ejemplo de c√°lculo (pseudoc√≥digo SQL / steps)

Obtener eventos relevantes (√∫ltimas N horas):

SELECT plate_text, COUNT(*) AS cnt,
       AVG( ST_DistanceSphere(geo, ST_MakePoint(:user_lon, :user_lat)) ) AS avg_dist,
       SUM(EXTRACT(EPOCH FROM (lead(timestamp) OVER (PARTITION BY track_id ORDER BY timestamp)
                                - timestamp))) AS total_seconds
FROM events
WHERE
  user_id = :user_id AND
  timestamp >= now() - INTERVAL '1 hour'
GROUP BY plate_text;


Calcular sub-scores en aplicaci√≥n/backend y combinar con par√°metros recuperados:

SELECT key, value FROM surveillance_params
WHERE key IN ('recurrence_weight','proximity_weight','persistence_weight', 'rarity_weight','warning_threshold','critical_threshold');


Aplicar las f√≥rmulas descritas en la capa de negocio (backend job) y guardar/actualizar suspicious_vehicles.

4.8 Storage & history

suspicious_vehicles.details guarda eventos clave (IDs) que justifican el score.

Mantener hist√≥rico de cambios (audit_log) por trazabilidad.

4.9 Reglas de validaci√≥n / mitigaci√≥n de falsos positivos

Requerir al menos min_count (ej. 2) para considerar score > 0.

Ignorar eventos con plate_conf < MIN_PLATE_CONF o model.signed=false a menos que S_stolen=1.

Aplicar voting sobre OCR: si plate aparece inconsistently (variaciones), usar consenso (majority of reads) y un edit_distance threshold.

5) Arquitectura del pipeline de inferencia (documento t√©cnico)

A continuaci√≥n la arquitectura detallada del pipeline de inferencia on-device ‚Äîm√≥dulos, interfaces, formatos, flujos, optimizaciones, estrategias de carga y fallback‚Äî pensada para Flutter (Android/iOS) con modelos YOLO y OCR en TFLite/ONNX.

5.1 Objetivo del pipeline

Procesar video en tiempo real (o casi real) desde la c√°mara del m√≥vil para:

detectar veh√≠culos y placas,

extraer crops,

ejecutar OCR,

asociar con tracker,

guardar evento en DB y generar alertas.

Todo con robustez ante modelos ausentes/incompatibles y con uso eficiente de CPU/GPU y bater√≠a.

5.2 M√≥dulos (interfaces y responsabilidades)

CameraManager

Responsabilidad: capturar frames desde la c√°mara y exponerlos al FrameSampler.

Configuraciones: resoluci√≥n base, fps c√°mara, ROI (regi√≥n de inter√©s).

Output: Frame (RGBA/YCbCr) + timestamp + camera_metadata (device orientation, focal length).

FrameSampler

Responsabilidad: decide qu√© frames pasar al pipeline seg√∫n pol√≠tica (e.g., 1 fps normal, 2‚Äì4 fps en tracking).

Pol√≠ticas: Normal, Tracking, BatterySaver.

Output: SampledFrame.

Preprocessor

Tareas: rotaci√≥n, correcci√≥n de orientaci√≥n, resize (mantener aspect ratio), normalization (float32 scaling), optional histogram equalization.

Produce: tensors con tama√±o requerido por el modelo (ej. 640√ó640).

Manejo de ROI: si user define ROI, crop antes del resize.

ModelRegistryManager (MRM)

Lee models_local/SIM.

Selecciona el modelo por task_type.

Validaciones: framework compat, input_size.

API: getModelForTask(task_type) retorna ModelDescriptor (path, input_size, signed, thresholds).

Responsible for model download/verify/activate.

InferenceRunner

Abstracci√≥n sobre runtime (TFLite, NNAPI, CoreML, metal delegate, Vulkan).

Funciones:

runDetection(frame_tensor) ‚Üí detections (boxes, labels, scores)

runOCR(crop_tensor) ‚Üí text + confidence

Optimizaci√≥n: use delegates, quantized models, native threads.

Batch support: if multiple crops, run batch inference.

PostProcessor

NMS (Non-Max Suppression) if model doesn't provide.

Mapping labels to semantic outputs.

Confidence thresholding.

Normalization of box coordinates from resized tensor to original frame.

CropManager

Extracts high-resolution crops from original frame (not the resized one) for OCR and attribute models.

Tracker Engine

Implementation: ByteTrack/DeepSort like.

Inputs: detections (boxes + embeddings if available).

Outputs: persistent track_id for a moving object.

Association policy: IoU + motion + appearance embeddings.

Integrates plate_text when available to anchor identity.

Attribute Pipelines

MakeModelDetector (optional): predicts make/model labels for the vehicle crop.

ColorDetector (optional): predicts color labels.

PlateDetector (if different from vehicle detector): finds plate box.

OCRRunner: receives plate crop(s) and outputs OCR text + confidence.

Voting mechanism over multiple frames within same track_id.

EventAssembler

Receives associated data (track_id, plate_text, makes, confidences, position).

Computes suspicious_score incrementally via local rules.

Stores event in events_local.

AlertEngine

Monitors incoming events; if stolen match or surveillance thresholds hit, issues UI/push alert and may toggle TrackingPolicy to Tracking.

SyncManager

Manages upload policies and batching to /v1/events/batch.

Respects user settings (Wi-Fi only, manual, anonymize).

Maintains synced flags.

ModelVerifier

On download, verifies file hash and digital signature.

Rejects model on mismatch.

Telemetry & Metrics

Tracks inference latency, FPS, memory usage, failed inferences.

Optional opt-in upload of aggregated metrics.

5.3 Data flow (step-by-step)

CameraManager ‚Üí FrameSampler decides to process frame F at t.

Preprocessor resizes/normalizes ‚Üí tensor T.

MRM provides vehicle_detector model descriptor.

InferenceRunner.runDetection(T) ‚Üí list of detections {bbox, label, score}.

PostProcessor applies NMS + thresholds ‚Üí valid boxes.

For each vehicle box:

CropManager extracts high-res crop C_vehicle (from original frame).

If make_model model present ‚Üí Preprocess crop ‚Üí InferenceRunner.runMakeModel ‚Üí record results.

If plate_detector model present on the frame or single-stage model returns plate ‚Üí crop plate.

OCR: crop plate to appropriate input_size ‚Üí InferenceRunner.runOCR ‚Üí get plate_text + plate_conf.

TrackerEngine updates/creates track using vehicle detections; returns track_id.

EventAssembler associates plate_text ‚Üí track_id (if multiple plates across frames, perform voting).

Persist to events_local with metadata including model_ids used.

AlertEngine checks stolen list / surveillance scoring, triggers actions if needed.

SyncManager batches unsynced events per policy and uploads.

5.4 Model formats & runtimes

Preferred local formats:

Android: TFLite (with NNAPI / GPU delegate), or ONNX with ORT Mobile + NNAPI.

iOS: CoreML converted models, or TFLite + Metal delegate.

Model packaging:

ZIP: {model.tflite, model.json (SIM), readme.md, signature.sig}

model.json must follow SIM.

Delegates:

Use GPU delegates when available and stable on device.

Fall back to CPU (quantized models for speed).

5.5 Performance & resource management

Target devices: gama media (ex: 4‚Äì8 CPU cores, 2‚Äì4 GB RAM). Optimize:

Default sampling 1 fps ‚Üí low CPU.

Tracking uses cheaper frame deltas (use motion estimation) to avoid full inference on every frame.

Use quantized models (INT8/FP16) for speed/size.

Memory:

Keep only active models in memory; unload models not active.

Cap number of concurrent inference threads (1-2) to avoid contention.

Battery:

Provide user profiles: Battery Saver, Balanced, Performance.

In Battery Saver: 0.5 fps, lower resolution, no GPU.

Concurrency:

Camera ‚Üí Producer thread.

InferenceQueue ‚Üí single consumer / bounded queue.

Tracker/DB writes ‚Üí background worker.

Timeouts & error handling:

If inference fails, retry up to N times (configurable), then log and continue.

If model is incompatible, MRM disables it and pipeline continues with placeholders (nulls).

5.6 Robustness & fallback policies

Model absence: pipeline continues; record nulls for missing attributes and mark model_used_* null.

Low OCR confidence: store plate as null; keep track_id for future reads. Use voting across frames to increase confidence.

Unsigned model: allow if user explicitly enables "allow unverified models" (advanced), but reduce weight of evidence (C_factor multiplier e.g. 0.6).

Batching crops for OCR: When track has multiple plate crops, send a batch to OCR runner for aggregated inference (reduces overhead).

5.7 Security checks in pipeline

Model signature/hash verification before activation (ModelVerifier).

Sandboxing: models run in controlled inference environment; do not execute arbitrary code.

Limits on model size: reject models > threshold unless user accepts.

Logging: store model_id used per event for audit.

5.8 Telemetry & metrics (what to measure)

Inference latency mean & p95 per model.

FPS achieved by pipeline.

Memory usage per model load.

OCR accuracy estimates (compare to user-corrected labels if opt-in).

Alerts rate & false alarm feedback (user reports).

5.9 Deployment & updates of models

Backend publishes models with SIM and signature.

App checks for updates periodically or on user request.

On new model activation, MRM runs health checks: small validation batch (local or test images) before set active.

5.10 Example component API (interfaces, high-level)

CameraManager.start() / .stop()

FrameSampler.setPolicy(policy)

MRM.getModel(task_type) -> ModelDescriptor

InferenceRunner.runDetection(tensor) -> detections[]

TrackerEngine.update(detections) -> tracks[]

EventAssembler.saveEvent(eventPayload)

AlertEngine.onEvent(eventPayload) -> may trigger UI

‚úÖ Cierre y recomendaciones r√°pidas

Los scripts SQL est√°n listos para usar como base. Adapta roles, usuarios y claves a tu infraestructura.

El pipeline propuesto prioriza robustez (fallback si faltan modelos), eficiencia (sampling din√°mico) y seguridad (verificaci√≥n de modelos).

El motor de contra-vigilancia se implementa mejor como job en backend que consume eventos y actualiza suspicious_vehicles, pero versiones simples pueden correr localmente para notificaciones instant√°neas (usar events_local + surveillance_params).

Antes de pruebas en campo, prepara un dataset representativo para validar thresholds y surveillance_params.

Si quieres ahora, puedo:

generar el script SQL de PostgreSQL adaptado a tu naming/roles exactos (por ejemplo esquema prod y owners),

o convertir el pipeline en un diagrama secuencial ASCII m√°s detallado paso a paso por m√≥dulo,

o preparar migraciones SQL ordenadas para el SQLite (versioned).

Dime cu√°l de esos (solo texto) quieres a continuaci√≥n y lo produzco.


toma solo lo que sea factible, optimiza loqu sea neceario y dame un plan para llevar acabo tod el proyecto, se puede hacer lo mas importante, 


----

ChatGPT dijo:

Perfecto. Vamos a integrar formalmente c√≥mo debe funcionar el mecanismo para cargar modelos YOLO seleccionados por el usuario desde la app, manteniendo seguridad, consistencia t√©cnica y evitando errores por modelos incompatibles.

A continuaci√≥n te entrego el m√≥dulo completo para a√±adirlo a la ‚ÄúEspecificaci√≥n T√©cnica v1.0‚Äù.

üîß Mecanismo para cargar modelos YOLO seleccionados por el usuario desde la app

Este apartado define c√≥mo la aplicaci√≥n m√≥vil permitir√° al usuario cargar modelos YOLO personalizados, ya sea:

Desde el backend oficial (repositorio seguro ‚Äî recomendado)

Desde almacenamiento local del usuario (archivo .zip, .tflite, .onnx, etc.)

Desde URL externa (solo si el usuario habilita ‚Äúpermitir modelos no verificados‚Äù)

La meta es evitar modelos inservibles o peligrosos, garantizar inferencias correctas y mantener compatibilidad entre modelos, entradas y salidas.

1. Formato est√°ndar de modelo (SIM) ‚Äî Security & Integrity Model

Cada modelo debe estar empacado en un paquete ZIP con la siguiente estructura:

/model/
    model.tflite √≥ model.onnx
    model.json      ‚Üê metadatos SIM
    labels.txt      ‚Üê opcional (si tasks: make/model/color)
    signature.sig   ‚Üê firma digital opcional
    readme.md       ‚Üê opcional

El archivo model.json (SIM) contiene:
{
    "model_id": "yolo-plate-detector-v1",
    "task_type": "plate_detector",
    "framework": "tflite",
    "input_size": [640, 640],
    "labels": ["vehicle", "plate"],
    "version": "1.0.0",
    "publisher": "usuario/local/backend",
    "file_hash": "sha256:xxxxx",
    "signed": true,
    "meta": {
        "recommended_conf_threshold": 0.35,
        "max_detections": 200,
        "nms": "built-in",
        "postprocess": "auto"
    }
}


Este JSON es indispensable para evitar:

confusi√≥n entre modelos incompatibles

tama√±os incorrectos de entrada

mapas de etiquetas err√≥neos

modelos corrompidos

versiones equivocadas

2. Flujo de carga de modelos (User-Selectable Model Loading)
Diferentes m√©todos permitidos
A) Selecci√≥n desde la app (backend oficial) ‚Äî modo seguro

El usuario elige:

detectores de autos

detectores de placas

OCR

modelos de color

modelos de marca/modelo

La app descarga el zip ‚Üí lo verifica ‚Üí lo activa.

B) Cargar desde archivo local

El usuario usa:

Abrir archivo

Seleccionar modelo YOLO

Importar ZIP desde almacenamiento interno

C) Cargar desde URL

Solo permitido si el usuario habilita:

‚ÄúPermitir modelos no verificados‚Äù

Para investigadores, testers o desarrolladores.

3. Proceso completo de verificaci√≥n y activaci√≥n de modelos

La app sigue una pipeline estricta:

(1) Usuario selecciona archivo/URL/backend
        ‚Üì
(2) App valida estructura ZIP
        ‚Üì
(3) Extrae y verifica model.json (SIM)
        ‚Üì
(4) Calcula hash SHA-256 del archivo modelo
        ‚Üì
(5) Compara con el hash del SIM
        ‚Üì
(6) Si tiene signature.sig ‚Üí verificar firma
        ‚Üì
(7) Validar compatibilidad con runtimes del dispositivo
        ‚Üì
(8) Registrar en DB (models_local) como "downloaded"
        ‚Üì
(9) Activar (active = 1) el modelo seleccionado por el usuario


Si algo falla:

se rechaza

se muestra error claro

el modelo no se activa

4. Validaciones estrictas antes de permitir activaci√≥n
‚úî Validar compatibilidad del framework

TFLite ‚Üí dispositivos Android/iOS compatibles

ONNX ‚Üí usar ONNX Runtime Mobile

CoreML ‚Üí solo iOS

Si no es compatible ‚Üí rechazar.

‚úî Validar input size

Ej. YOLOv8 suele usar 640√ó640.
Si el modelo dice 512√ó512, la app debe adaptar el preprocesamiento.
Si es un tama√±o no soportado ‚Üí rechazar.

‚úî Validar que task_type est√© permitido

Lista de task types aceptados:

vehicle_detector

plate_detector

ocr

make_model_classifier

color_classifier

Si viene un tipo fuera de esta lista ‚Üí rechazar.

‚úî Validar que labels coinciden con la tarea

Ej. un detector de placas debe tener etiquetas tipo ["license_plate"].

‚úî Validar tama√±o m√°ximo

Evitar modelos gigantes:

l√≠mite recomendado: ‚â§ 40 MB

Si excede ‚Üí pedir confirmaci√≥n al usuario.

5. Gesti√≥n de m√∫ltiples modelos por tarea

Cada categor√≠a puede tener N modelos cargados pero solo uno activo.

Tabla models_local:

Campo	Uso
model_id	Identificador √∫nico
task_type	Tipo del modelo
active	0/1 indica el modelo activo
file_path	Ruta local del modelo
signed	Indica si tiene firma
file_hash	Verificaci√≥n
labels	Para clasificaciones
version	Control de versiones
Reglas:

Solo un modelo activo por task_type.

Si el usuario activa un nuevo modelo, el anterior pasa a active = 0.

Nunca borrar autom√°ticamente modelos (el usuario decide).

6. Interfaz completa para el usuario (UX/UI)

La secci√≥n ‚ÄúModelos de IA‚Äù debe incluir:

Pantallas:

Modelos de detecci√≥n

Modelos de OCR

Modelos de marca/modelo

Modelos de color

Modelos avanzados

Opciones:

Agregar modelo

Desde archivo

Desde URL

Desde biblioteca oficial

Ver detalles

versi√≥n

publisher

firma digital

fecha de carga

tama√±o

Activar modelo

Eliminar modelo

Restablecer a modelo por defecto

Modo avanzado:

Permitir modelos sin firma

Permitir modelos de gran tama√±o

Mostrar logs del pipeline

7. Integraci√≥n con el Pipeline de Inferencia

Cuando el pipeline necesita un modelo:

vehicleDetector = MRM.getModelForTask("vehicle_detector")


MRM = Model Registry Manager

El MRM:

busca en models_local

valida que est√© activo y disponible

carga en memoria

activa el runtime correspondiente (TFLite / ONNX / CoreML)

reporta errores si el modelo no es compatible

Nunca se invoca un modelo que el usuario no haya activado.

8. Manejo de errores comunes
Error	Acci√≥n de la App
ZIP corrupto	mensaje claro, descartar archivo
model.json ausente	descartar
hash incorrecto	descartar y advertir sobre posible alteraci√≥n
modelo incompatible	bloquear y explicar motivo
modelo demasiado grande	pedir confirmaci√≥n
labels inv√°lidos	rechazar
9. Recomendaciones de seguridad

Modelos sin firma ‚Üí ejecutar con capacidad reducida (menor puntuaci√≥n en algoritmo).

No permitir ejecuci√≥n directa de c√≥digo.

Limitar acceso a carpetas fuera del sandbox.

Validar siempre integridad del ZIP.

Mantener audit log de modelos instalados.

10. Entrada para la Especificaci√≥n T√©cnica v1.0

Si quieres, integro todo este m√≥dulo en el documento global ‚ÄúEspecificaci√≥n T√©cnica v1.0‚Äù como:

Secci√≥n 6. Gesti√≥n y carga de modelos YOLO (SIM + Model Registry Manager)




üìÑ ESPECIFICACI√ìN T√âCNICA ‚Äî VERSI√ìN 1.0

Sistema de Detecci√≥n Inteligente Multi-Modelo con Contra-Vigilancia Autom√°tica
(Aplicaci√≥n M√≥vil + Backend + IA + BD + Model Registry)

0. Declaraci√≥n de Modelo y Prevenci√≥n de Errores

Para evitar errores en la arquitectura, implementaciones incorrectas y confusiones entre modelos, la aplicaci√≥n debe hacer uso de:

Modelo de Arquitectura Est√°ndar:

Frontend: Flutter

Backend: Node.js + PostgreSQL

Base local m√≥vil: SQLite

IA: Modelos YOLO en formatos TFLite, ONNX o CoreML

Motor de reglas: Pipeline de inferencia con m√≥dulo de contra-vigilancia

Formato est√°ndar de modelos (SIM ‚Äì Security & Integrity Model)

Model Registry Manager (MRM) para activar y administrar modelos sin riesgo

Control de versiones para prevenir incompatibilidades entre modelos y tareas

Validaci√≥n estricta del paquete de modelo antes de habilitarlo

1. DIAGRAMA ER COMPLETO DEL SISTEMA (ASCII)
+-------------------+       +------------------------+
| users             |       | sessions               |
|-------------------|       |------------------------|
| user_id PK        |<-----| session_id PK          |
| email             |       | user_id FK             |
| role              |       | token                  |
| created_at        |       | expires_at             |
+-------------------+       +------------------------+

+------------------------------------------------------------+
| models_local                                               |
|------------------------------------------------------------|
| model_id PK                                               |
| task_type                                                 |
| version                                                   |
| framework (tflite/onnx/coreml)                            |
| file_path                                                 |
| labels JSON                                               |
| file_hash                                                 |
| signed BOOLEAN                                            |
| active BOOLEAN                                             |
| source (‚Äúbackend‚Äù, ‚Äúlocal‚Äù, ‚Äúurl‚Äù)                        |
| created_at                                                |
+------------------------------------------------------------+

+----------------------+        +--------------------------+
| detections           |        | ocr_results              |
|----------------------|        |--------------------------|
| detection_id PK      |        | ocr_id PK                |
| image_id FK          |        | detection_id FK          |
| model_id FK          |        | text                     |
| label                |        | confidence               |
| confidence           |        | created_at               |
| bbox JSON            |        +--------------------------+
| created_at           |
+----------------------+

+---------------------------+
| images                    |
|---------------------------|
| image_id PK               |
| path                      |
| width                     |
| height                    |
| created_at                |
+---------------------------+

+---------------------------------+
| rule_engine_events              |
|---------------------------------|
| event_id PK                     |
| detection_id FK                 |
| rule_name                       |
| severity                        |
| triggered BOOLEAN               |
| created_at                      |
+---------------------------------+

2. SCRIPT COMPLETO PARA POSTGRESQL (LISTO PARA EJECUTAR)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE users (
    user_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    role TEXT NOT NULL DEFAULT 'user',
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE sessions (
    session_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(user_id),
    token TEXT NOT NULL,
    expires_at TIMESTAMP NOT NULL
);

CREATE TABLE models_local (
    model_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    task_type TEXT NOT NULL,
    version TEXT NOT NULL,
    framework TEXT NOT NULL,
    file_path TEXT NOT NULL,
    labels JSONB,
    file_hash TEXT NOT NULL,
    signed BOOLEAN DEFAULT false,
    active BOOLEAN DEFAULT false,
    source TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE images (
    image_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    path TEXT NOT NULL,
    width INT,
    height INT,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE detections (
    detection_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    image_id UUID REFERENCES images(image_id),
    model_id UUID REFERENCES models_local(model_id),
    label TEXT NOT NULL,
    confidence NUMERIC NOT NULL,
    bbox JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE ocr_results (
    ocr_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    detection_id UUID REFERENCES detections(detection_id),
    text TEXT NOT NULL,
    confidence NUMERIC,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE rule_engine_events (
    event_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    detection_id UUID REFERENCES detections(detection_id),
    rule_name TEXT NOT NULL,
    severity TEXT NOT NULL,
    triggered BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT NOW()
);

3. SCRIPT SQL PARA SQLITE OPTIMIZADO PARA FLUTTER
CREATE TABLE models_local (
    model_id TEXT PRIMARY KEY,
    task_type TEXT,
    version TEXT,
    framework TEXT,
    file_path TEXT,
    labels TEXT,
    file_hash TEXT,
    signed INTEGER,
    active INTEGER,
    source TEXT,
    created_at TEXT
);

CREATE TABLE images (
    image_id TEXT PRIMARY KEY,
    path TEXT,
    width INTEGER,
    height INTEGER,
    created_at TEXT
);

CREATE TABLE detections (
    detection_id TEXT PRIMARY KEY,
    image_id TEXT,
    model_id TEXT,
    label TEXT,
    confidence REAL,
    bbox TEXT,
    created_at TEXT
);

CREATE TABLE ocr_results (
    ocr_id TEXT PRIMARY KEY,
    detection_id TEXT,
    text TEXT,
    confidence REAL,
    created_at TEXT
);

CREATE TABLE rule_engine_events (
    event_id TEXT PRIMARY KEY,
    detection_id TEXT,
    rule_name TEXT,
    severity TEXT,
    triggered INTEGER,
    created_at TEXT
);

4. RELACIONES Y REGLAS PARA EL ‚ÄúALGORITMO DE CONTRA-VIGILANCIA‚Äù

El sistema implementa un motor de reglas basado en heur√≠sticas e inferencia ligera para identificar patrones de vigilancia sospechosa.

4.1 Conceptos Clave

Detecci√≥n primaria: veh√≠culos, placas, rostros.

Detecci√≥n secundaria: OCR de placas u objetos.

Eventos derivados: patrones de seguimiento, recorridos repetitivos, objetos inusuales.

Reglas contextuales: condiciones ambientales, tiempo, ubicaci√≥n.

4.2 Reglas (ejemplos)
Regla 1: Repetici√≥n de la misma placa en menos de 2 horas ‚Üí ‚ÄúSeguimiento sospechoso‚Äù
Regla 2: Veh√≠culo estacionado 3+ veces consecutivas en el mismo punto ‚Üí ‚ÄúPosible vigilancia‚Äù
Regla 3: Objeto no identificado + persona en posici√≥n fija ‚Üí ‚ÄúMonitoreo pasivo‚Äù
Regla 4: Movimiento circular repetido ‚Üí ‚ÄúPatr√≥n perimetral‚Äù
Regla 5: Discrepancias en OCR y Detector ‚Üí ‚ÄúManipulaci√≥n visual‚Äù

4.3 L√≥gica del motor

Recibe detecciones

Enlaza con resultados OCR

Consulta historial en BD

Eval√∫a reglas basadas en:

frecuencia

repetici√≥n

variaci√≥n espacial

correlaci√≥n hora-lugar

Genera evento en rule_engine_events

Notifica al usuario si la severidad ‚â• ‚Äúmedium‚Äù

5. ARQUITECTURA DEL PIPELINE DE INFERENCIA (DOCUMENTO T√âCNICO)
          [INPUT CAMERA]
                 ‚Üì
            Preprocesamiento
                 ‚Üì
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ML Model Loader ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ Model Registry Manager (MRM)    ‚îÇ
     ‚îÇ ‚Ä¢ Valida                       ‚îÇ
     ‚îÇ ‚Ä¢ Verifica hash                ‚îÇ
     ‚îÇ ‚Ä¢ Activa modelos por tarea     ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚Üì
        Inferencia (YOLO)
                 ‚Üì
      Postprocesamiento (NMS)
                 ‚Üì
    OCR Engine (si la tarea lo requiere)
                 ‚Üì
      Motor de Reglas (Contra-Vigilancia)
                 ‚Üì
            Eventos y Alertas
                 ‚Üì
                BD

5.1 M√≥dulos

MRM: garantiza que solo se use un modelo seguro y validado.

Preprocesamiento: resize, normalizaci√≥n.

Postprocesamiento: NMS, decodificaci√≥n de etiquetas.

OCR: Tesseract OCR m√≥vil o modelo ONNX.

Context Evaluator: correlaciona detecciones.

6. GESTI√ìN Y CARGA DE MODELOS YOLO SELECCIONADOS POR EL USUARIO
6.1 Formato SIM (Security & Integrity Model)

Todo modelo se distribuye como ZIP:

/model/
    model.onnx / model.tflite
    model.json   ‚Üê metadatos obligatorios
    labels.txt
    signature.sig (opcional)


Ejemplo de model.json:

{
    "model_id": "yolo-plate-v1",
    "task_type": "plate_detector",
    "framework": "tflite",
    "input_size": [640,640],
    "labels": ["plate"],
    "version": "1.0.0",
    "publisher": "backend",
    "file_hash": "sha256:xxxx",
    "signed": true
}

6.2 M√©todos de carga permitido

Desde el backend oficial (seguro)

Desde archivo local (ZIP)

Desde URL externa (modo avanzado)

6.3 Pipeline de validaci√≥n
Usuario selecciona modelo
        ‚Üì
Validar estructura ZIP
        ‚Üì
Leer model.json
        ‚Üì
Calcular SHA-256 y comparar
        ‚Üì
Verificar firma (si existe)
        ‚Üì
Validar framework y compatibilidad
        ‚Üì
Registrar modelo en BD
        ‚Üì
Activar modelo seleccionado

6.4 Reglas de activaci√≥n

Solo un modelo activo por tarea (vehicle, plate, color, OCR).

El usuario puede activar/desactivar modelos.

El sistema nunca usa un modelo no activado.

6.5 Validaciones estrictas

Tama√±o m√°ximo sugerido: ‚â§ 40 MB

Solo tareas permitidas:

vehicle_detector

plate_detector

ocr

make_model_classifier

color_classifier

input_size v√°lido

labels consistentes

framework compatible con el dispositivo

FIN DEL DOCUMENTO